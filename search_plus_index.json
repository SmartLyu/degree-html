{"./":{"url":"./","title":"介绍","keywords":"","body":"考研笔记 源位置： GitHub 加速网址：国内地址 感悟想法 沟通 \\iff 传输 + 回馈 When Who in Where do What for Why, and How to delelte 生活数学式 (1.01)^{365} = 37.8 , (1.02)^{365} = 1377.4 (0.09)^{365} = 0.03 , (0.98)^{365} = 0.0002 积少成多，流沙易逝，所有的成败都取决于一个坚持，坚持积累，坚持不放纵自己才能成功。 \\lim_{t->now}{过程} = 行动 当时间无限趋近现在这个时间点，所谓过程 就是 当前做的行动 (过程 + 过去)' = 行动的结果 \\int (结果) + 过去 = 过程 过去 是一个常量 ， 而 整个进行了的过程​ 的导数(趋势) 就必然指向了​未来的结果 ， 而累计的无数已行结果 的积分就是 整个过程 综1、2上： 任何漫长的过程，都是无数有作为的行动组成的； 过程和结果没有重要性区别，已行过程决定未来结果，已有结果组成整个过程。 问题分析的泰勒公式 问自己一次 why 即一个高阶求导，公式如下： 问题 = Why + \\frac{Why(Why)}{1!} + \\frac{Why(Why(Why))}{2!} + \\frac{Why(Why(Why(Why)))}{3!} ... + o(why^n) (余项即累计经验) 反复问自己：\"这是为什么\"；得出结论后，在问：\"这又是为什么\" ，不断循环，就能分析清楚，而累计的经验即余项； 越多次反问、越丰富经验，就能更接近真相。 "},"Political/":{"url":"Political/","title":"政治","keywords":"","body":"政治总结 "},"Political/Marxism.html":{"url":"Political/Marxism.html","title":"马克思主义基本原理","keywords":"","body":"马原 马原基本三部曲：昨天 - 今天 - 明天 通过分许过去得出：时代在进步，未来在发展，人民来推动 -> 马哲 通过批判今天得出：资本主义必然灭亡 -> 政经 通过指明未来得出：社会主义必然胜利 -> 科社 历史背景 社会根源： 资本主义的发展及其内在矛盾激化 1837年，第一个无产阶级政党： 共产主义同盟 马恩实践上的贡献：积极投身工人运动中 马恩理论上的贡献：洗手德国古典哲学、英国古典政治经济学、英法的空想社会主义合理成分 根本原因 因为 1. 资本主义的发展及其内在矛盾激化 (时势造英雄) 成立标志 1848年，马克思发表了《共产党宣言》 马克思主义俄国化 理论发展：提出社会主义革命可能在一个国家先发生 实践探索：十月革命，把社会主义从理论变成实践，建立第一个社会主义制度 马克思是把空想变成理论，列宁把理论变为实践 马克思主义当代最新理论成果 最新成果是：习近平新时代中国特色社会主义思想 其是党和人民实践经验和集体智慧的结晶 内涵和特征 内涵 马克思主义是由马恩创立，尤其后各个时代、民族的马克思主义者丰富和发展的观点和学说体系 研究对象： 关于自然、社会和人类思维的学说 目的： 关于社会主义必然取代自办主义，最终实现共产主义的学说 意义：关于无产阶级解放、全人类解放和每个人自由而全面发展的学说 理论体系 马克思主义哲学、马克思主义政治经济学、科学社会主义 哲学：理论基础 政经：现实运用 科社：方向、核心和目的 "},"Math/":{"url":"Math/","title":"高数","keywords":"","body":"高数总纲 基础知识点 二倍角公式、诱导公式、扩角公式 注意： 在设计三角函数的相关题目中，\\cos{x}\\cos{x} \\pm \\sin{x}\\sin{x} 等要常常化简，化简后再运算。 复合求导计算公式 基础求导 \\begin{array}{|c|c|} \\hline (a^x)' ={lna} \\cdot a^x & (log_{a}{x})'=\\frac{1}{xlna}\\\\ \\hline (x^x)' = x^x(1+lnx) & ln'(x+\\sqrt{1+x^2}) = \\frac{1}{\\sqrt{1+x^2}}\\\\ \\hline \\tan'(x) = \\frac{1}{\\cos^2(x)} = \\sec^2(x) & \\cot'(x) = -\\frac{1}{\\sin^2(x)} = -\\csc^2(x) \\\\ \\hline \\sec'(x) = \\sec(x)\\tan(x) & \\csc'(x) = -\\csc(x)\\cot(x) \\\\ \\hline \\arcsin'(x) = \\frac{1}{\\sqrt{1-x^2}} & \\arccos'(x) = -\\frac{1}{\\sqrt{1-x^2}} \\\\ \\hline \\arctan'(x) = \\frac{1}{1+x^2} & \\arccos'(x) = -\\frac{1}{1+x^2} \\\\ \\hline arcsec'(x) = \\frac{1}{\\vert{x}\\vert\\sqrt{x^2-1}} & arccsc'(x) = -\\frac{1}{\\vert{x}\\vert\\sqrt{x^2-1}} \\\\ \\hline \\end{array} 基础不等式 \\frac{a+b}{2} \\ge \\sqrt{ab} \\Rightarrow \\frac{a_1+a_2..a_n}{n} \\ge \\sqrt[n]{a_1 \\cdot a_2 ... \\cdot a_n} ... ... "},"Math/Limit.html":{"url":"Math/Limit.html","title":"极限","keywords":"","body":"极限相关知识 考点 对求极限中，需要 分左右极限 考虑问题： 存在分段点(带有绝对值的、分段函数) e^\\infty 类型： e^+\\infty \\rightarrow +\\infty，e^-\\infty \\rightarrow 0 \\arctan(\\infty) 类型 ， \\arctan(+\\infty) = \\pi/2 ， \\arctan(-\\infty) = -\\pi/2 f(x)在(a,b) 连续 ，且\\lim_{x \\rightarrow a^+}{f(x)}和\\lim_{x \\rightarrow b^-}{f(x)} 存在 ，f(x)在(a,b) 有界。 f(x)在[a,b] 连续，f(x)在[a,b]有界。 若\\lim{f(x)}存在 ，\\lim{g(x)}不存在 ，则\\lim{f(x) \\pm g(x)} 一定不存在 若\\lim{f(x)}不存在 ，\\lim{g(x)}不存在 ，则\\lim{f(x) \\pm g(x)} 不一定存在 综上： 2存在\\Rightarrow 存在 || 1存在1不存在\\Rightarrow 不存在 || 2不存在\\Rightarrow 不确定 存在性质： 夹逼准则：当 分子分母都在动，需要预估上下限，使用夹逼准则，动分子不动分母 (求和不用通分) 单调有界 \\Rightarrow 有极限 ：证明单调性可以用归纳法证明单调性 无穷小性质： 无穷小 与 有界变量乘积 的乘积还是无穷小，即\\lim = 0 知道某极限为0可以，进行计算某函数的表达式 \\lim{f(x)} =0 \\Rightarrow f(x) = 0+ \\alpha (\\alpha为无穷小) x \\to +\\infty ，时候，判定级别大小： \\ln^{\\alpha}x 小 除 大 值是：无穷小 求极限 链接 注意点： 先 变形(又加减幂指转为乘除) 化简 再用 公式 ** x \\sim \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 只有 乘除 才可以使用 等价无穷小 、先计算一部分不为0的部分 ** 只有 拆分极限后两个极限都存在 的时候才可以使用 极限运算法则 ** 针对 幂指函数 问题，需要先判断 底数 极限是 0或1 题型分析： e^{f(x)} - e^{g(x)} = e^{g(x)} [e^{f(x)-g(x)} - 1] \\sim [{f(x)-g(x)}] \\cdot e^{g(x)} 分子为 两根式相加减 ，先 有理化 ，而一般提出那部分不是0，可以先算出来： \\lim{\\sqrt\\alpha - \\sqrt\\beta} = \\lim{(\\alpha - \\beta) \\frac{1}{\\sqrt\\alpha + \\sqrt\\beta}} 题目中有 \\frac{1}{x} ,使用倒代换，令t=\\frac{1}{x} \\lim{(\\tan(x) - \\sin(x))} = \\lim{(\\tan(x)(1-\\cos(x))} = \\lim{(\\frac{x^3}{2})} 合1、3： \\lim{(e^{\\tan(x)} - e^{\\sin(x)})} = lim{\\frac{x^3e^{\\sin(x)}}{2}} u(x)^{v(x)} == e^{v(x)\\ln{u(x)}} 由此变形幂指处理为乘除问题，注意u(x) 极限是否为1(查看题型6)； \\ln'(x+\\sqrt{1+x^2}) = \\frac{1}{\\sqrt{1+x^2}} ** 求1^{\\infty}类型时候，其 \\lim{u(x)} = 1 , \\lim{v(x)} = \\infty ，所以可以直接用 \\lim{u(x)^{v(x)}} = \\lim{e^{v(x)[u(x)-1]}} 泰勒公式 题型分析： 分式模式，且分母是多项式 泰勒公式展开式达到什么级别即可，展开达到 分母的指数 即可 两个可拆分泰勒公式加减 的时候，展开达到 第一次同次方 系数不能抵消 数列求极限： 题型分析： 无限项和 求极限：找数列中的 最大项、最小项，做夹逼准则：\\lim{n \\cdot a_1} \\le \\lim{a_1..a_n} \\le \\lim{n \\cdot a_n} 有限项和 求极限：只找有限数列中的 最大项 (可以假设某项为最大)，做夹逼准则：\\lim{n \\cdot a_{max}} \\le \\lim{n \\cdot (a_1..a_m)} \\le \\lim{n \\cdot m \\cdot a_{max}} ** \\lim_{n \\to \\infty}{\\sqrt[n]{a_1^n+a_2^n..a_m^n}} = max(a_1,a_2..,a_m) ... 求函数间断点，再求左右极限 (看考点1)，最后确认间断点类型： 无定义点 分段点 确认间断点类型，分四种情况： 左极限 = 右极限 = 函数值 \\Rightarrow 连续 左极限 = 右极限 \\ne 函数值 \\Rightarrow 可去间断点 左极限 \\ne 右极限 \\Rightarrow 跳跃间断点 左右某个极限不存在 \\Rightarrow 第二间断点 复杂f(b)-f(a)相关极限问题，可以使用 拉格朗日中值定理 解决 .... 邻域 区间 (x_0 - \\delta , x_o + \\delta ) 称为x_0 在\\delta 邻域，去掉x_0 称为去心邻域 \\delta 称为邻域半径(这个值会很小) 极限定义 对一个点的极限 -\\delta 且 x \\neq x_0 , |f(x)-a| , \\varepsilon , \\delta 无限小 称为x \\rightarrow x_0 的极限为a 记：\\lim_{x \\rightarrow x_0}{f(x)} = a 单侧极限： \\lim_{x\\rightarrow x_0^-}{f(x)} 左极限 \\lim_{x\\rightarrow x_0^+}{f(x)} 右极限 定理： \\lim_{x \\rightarrow x_0}{f(x)} = a \\iff \\lim_{x\\rightarrow x_0^-}{f(x)}= \\lim_{x\\rightarrow x_0^+}{f(x)} = a 对无限的极限 |x| , |f(x)-a| , \\varepsilon 无限小, X 无限大 称为x \\rightarrow \\infty 的极限为a 记：\\lim_{x \\rightarrow \\infty}{f(x)} = a 单侧极限： \\lim_{x\\rightarrow -\\infty}{f(x)} 左极限 \\lim_{x\\rightarrow +\\infty}{f(x)} 右极限 定理2： \\lim_{x \\rightarrow \\infty}{f(x)} = a \\iff \\lim_{x\\rightarrow -\\infty}{f(x)}= \\lim_{x\\rightarrow +\\infty}{f(x)} = a 性质 一般性质 唯一性： 极限存在即唯一 局部有界性： 极限存在具体值，则f(x) 在x \\rightarrow x_0 有界 ** 极限正、函数正 | 极限负、函数负 运算性质 设 \\lim{f(x)}=A(\\exists) ,\\lim{g(x)}=B(\\exists) \\lim{f(x)\\pm g(x)}=\\lim{f(x)} \\pm \\lim{g(x) = A \\pm B} \\lim{f(x). g(x)}=\\lim{f(x)} . \\lim{g(x) = A . B} \\lim{\\frac {f(x)}{g(x)}}= \\frac{\\lim{f(x)}}{\\lim{g(x)}} = \\frac{ A }{B} 存在性质 夹逼准则： x_n \\leq y_n \\leq z_n , \\lim_{n\\to\\infty}{x_n}=\\lim_{n\\to\\infty}{z_n}=a 则 \\lim_{n\\rightarrow\\infty}{y_n}=a 单调增有上界的数列、单调减有下界的数组 \\Rightarrow 数组有极限 无穷小 无穷小定义 \\lim_{x \\to x_o}{f(x)} = 0 时，f(x) 为 x \\to x_0时的无穷小 无穷小比较 高阶 若\\lim{\\frac{\\alpha}{\\beta}} = 0 ，称 \\alpha 是 \\beta 的高阶无穷小，记： \\alpha = o(\\beta) 同阶 若\\lim{\\frac{\\alpha}{\\beta}} = C \\ne 0 ，称 \\alpha 是 \\beta 的同阶无穷小 等价 若\\lim{\\frac{\\alpha}{\\beta}} = 1 ，称 \\alpha 是 \\beta 的等价无穷小 无穷小性质 ** 无穷小 与 有界变量乘积 的乘积 为无穷小 有限个 无穷小 的 乘积(和) 为无穷小 无限个 无穷小 的 乘积(和) 不一定为无穷小 极限与无穷小的关系 \\lim_{x \\to *}{f(x)} = a \\iff f(a) = a + \\beta 则 其中 \\beta 是 x \\to * 时的无穷小 求极限(七种类型) \\frac{0}{0} 类型 方法： 等价代换、洛必达、泰勒公式 1. 常用等价无穷小 x \\sim \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 1-\\cos(x) \\sim \\frac{1}{2}x^2 (1+x)^a -1 \\sim ax a^x -1 \\sim x\\ln{a} \\Rightarrow e^x -1 \\sim x 重点等价无穷小 ( x - x等价项 )： x 的等价项： \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 x-\\sin(x) \\sim \\frac{x^3}{6} \\Rightarrow \\arcsin(x) - x \\sim \\frac{x^3}{6} \\tan(x) - x \\sim \\frac{x^3}{3} \\Rightarrow x - \\arctan(x) \\sim \\frac{x^3}{3} x - \\ln(1+x) \\sim \\frac{x^2}{2} 注 ： x 可以是 f(x) ， 只要 f(x) \\to 0 即可 只有乘除才可以使用等价无穷小 2. 洛必达法则 当 \\lim_{x \\to x_o}{f(x)}=\\lim_{x \\to x_o}{g(x)}=0 或者 \\infty 时： \\lim_{x \\to x_o}{\\frac{f(x)}{g(x)}} = \\lim_{x \\to x_o}{\\frac{f'(x)}{g'(x)}} \\frac{\\infty}{\\infty} 类型 方法：洛必达法则、分子分母同除最大量、抓大头 抓大头： 极限中出现 \\infty - 0 ，可以选择不理会 0 的项式 注： 遇到题目先考虑洛必达法则 当 x \\to - \\infty 时候，x为负数，开跟等要有负号 0 \\cdot \\infty 类型 方法：化为 \\frac{0}{0} 或者 \\frac{\\infty}{\\infty} 注： 一般 对数 、反三角 作分子 \\lim_{x \\to 0}{x \\ln(x)} = 0 \\infty - \\infty 方法： 通分、有理化、倒带换 化为 \\frac{0}{0} 或者 \\frac{\\infty}{\\infty} 注： 题目中有 \\frac{1}{x} ,使用倒代换，令t=\\frac{1}{x} 0^0,\\infty^0 类型 方法：变形为乘除 u(x)^{v(x)} == e^{v(x)\\ln{u(x)}} 1^{\\infty}类型 方法：\\lim{u(x)^{v(x)}} = \\lim{e^{v(x)[u(x)-1]}} 计算过程： \\lim{u(x)^{v(x)}} = \\lim{e^{v(x)\\ln[1+u(x)-1]}} = \\lim{e^{v(x)[u(x)-1]}} 运用等价代换 \\ln(x) \\sim x 泰勒公式 通式： f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f^{(3)}(x_0)(x-x_0)^3 + .... +\\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n + o(x^n) f(x) = f(0) + f'(0)x + \\frac{1}{2!}f''(0)x^2 + \\frac{1}{3!}f'''(0)x^3 + o(x^3) (麦克劳林公式) 注： o(x^2)是x^2的无穷小值，故 o(x^2) \\pm o(x^2) = o(x^2) , 且 \\lim{o(x^2)} = 0 o(x^m) \\pm o(x^n) = o(x^{\\max{(m,n)}}) o(x^m) \\cdot o(x^n) = o(x^{(m+n)}) 通项拆分指南： 分式模式，且分母是多项式 泰勒公式展开式达到什么级别即可，展开达到 分母的指数 即可 两个可拆分泰勒公式加减 的时候，展开达到 第一次同次方 系数不能抵消 考纲必用-泰勒公式 \\sin{x} = x - \\frac{1}{3!}x^3 + o(x^3) \\cos{x} = 1 - \\frac{1}{2!}x^2 + \\frac{1}{4!}x^4 + o(x^4) \\arcsin{x} = x + \\frac{1}{3!}x^3 + o(x^3) \\tan{x} = x + \\frac{1}{3}x^3 + o(x^3) \\arctan{x} = x - \\frac{1}{3}x^3 + o(x^3) \\ln(1+x) = x - \\frac{1}{2}x^2 + \\frac{1}{3}x^3 + o(x^3) e^x = 1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 + o(x^3) (1+x)^a = 1 + ax + \\frac{a(a-1)}{2!}x^2 + o(x^2) 数列求极限 求n项和的极限 方法： 先求和、夹逼准则、定积分 记忆：\\lim_{n \\to \\infty}{\\sqrt[n]{a_1^n+a_2^n..a_m^n}} = max(a_1,a_2..,a_m) 夹逼准则注： 无限项和 求极限：找数列中的 最大项、最小项，做夹逼准则： \\lim{n \\cdot a_1} \\le \\lim{a_1..a_n} \\le \\lim{n \\cdot a_n} 有限项和 求极限：只找有限数列中的 最大项 (可以假设某项为最大)，做夹逼准则： \\lim{n \\cdot a_{max}} \\le \\lim{n \\cdot (a_1..a_m)} \\le \\lim{n \\cdot m \\cdot a_{max}} 由递推公式计算极限 方法：单调有界准则 具体方法： 证明单调性及其对应的上界或下界 (可以先求好证的拿分) 令\\lim{x_n} = A，则\\lim{x_{n+1}} = A (极限存在则唯一) ， 在递推公式两边同时取极限 连续和间断 定义1：若y=f(x)在x_0的领域内有定义，则\\lim_{x \\to x_0}{f(x)} = f(x_0) \\iff y=f(x) 在x_0处连续 定义2：若y=f(x)在x_0的去心领域内有定义，则y=f(x) 在x_0处不连续 ，x_0是f(x) 的间断点 间断点分类 第一类间断点：左右极限 都存在 可去间断点：左右极限 存在且相等 跳跃间断点：左右极限 存在但不等 第二类间断点：左右极限 至少一个不存在 连续函数规则 f(x),g(x)在x=x_0连续，则f(x) \\pm g(x) , f(x) \\cdot g(x)都连续； 当g(x_0) \\ne 0时候，\\frac{f(x)}{g(x)}连续 y=f(u),u=\\varphi(x)在u=u_0连续，则f(\\varphi(x))连续； y=f(x)单调连续，则x=\\varphi(y)连续 连续函数性质 闭区间下才成立 有界 有最大最小值 介值定理：介于最小、最大值之间的任意数\\mu，必然\\exists \\alpha 在闭区间内，使得f(\\alpha)=\\mu 零点定理：若f(x)在[a,b]之间连续，且f(a) \\cdot f(b) ，则存在f(\\mu)=0 "},"Math/Derivatives-Integrals.html":{"url":"Math/Derivatives-Integrals.html","title":"导数与积分","keywords":"","body":"导数 考点 分段函数 求左导数、右导数，必须严格使用 定义 计算 分析 一个点的导数 问题，用 定义 处理 参数方程的二次导数(证明过程看下面导数计算)： y'' =\\frac{(\\frac{y'(t)}{x'(t)})'}{x'(t)} 计算高阶导的时候，只有当u 、 v的某个导数 (幂函数) 可以迅速为0的时候使用莱布尼茨公式 ... 导数定义 定义1：导数： f'(x_0) = \\lim_{\\Delta x \\to 0}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 若极限存在，导数存在； 若极限不存在，导数不存在。 注： \\Delta x 必须可正可负 导数定义另一形式：f'(x_0) = \\lim_{x \\to x_0}{\\frac{f(x) - f(x_0)}{x-x_0}} 导数定义中分子必须出现“ - f(x_0) ” 定义2：左导数：f_-'(x_0) = \\lim_{\\Delta x \\to 0^-}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 定义3：右导数：f_+'(x_0) = \\lim_{\\Delta x \\to 0^+}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 定理：f'(x_0) = A \\iff f_-'(x_0) = f_+'(x_0) = A 导数几何意义 导数即是函数的切线斜率 切线方程： y - f(x_0) = f'(x_0)(x-x_0) 法线方程： y - f(x_0) = -\\frac{1}{f'(x_0)}(x-x_0) (f'(x_0) \\ne 0 ) 微分定义 \\Delta y = A \\Delta x , A 是常数 则y = f(x)可微，而dy = A \\Delta x称为微分 定理：y=f(x) 在x=x_0上，可微 \\iff 可导 ，且dy = f'(x)dx 微分几何意义 局部的“以取代直”，用y = dy + y_0 切线近似代替曲线y=f(x) 微分：dy 是切线在 横坐标\\Delta x内的 纵坐标改变量 ​ 而真实曲线纵坐标改变量是 \\Delta y ，当\\lim{\\Delta x} = 0时，dy = \\Delta y 连续、可导、可微 连续未必可导 可导一定连续 可导等价可微 导数计算 基础 ... 反函数求导： x_y' = \\frac{1}{y_x'} 隐函数求导： F(x-y) = 0，两端对 x 求导，得y' 参数方程求导：y' = \\frac{y'(t)}{x'(t)} 参数方程的二次导数： y'' = \\frac{d^2y}{dx^2} = \\frac{d}{dx}(\\frac{dy}{dx}) = \\frac{d}{dx}(\\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}) = \\frac{d}{dx}(\\frac{y'(t)}{x'(t)}) = \\frac{\\frac{d(\\frac{y'(t)}{x'(t)})}{dt}}{\\frac{dx}{dt}} = \\frac{(\\frac{y'(t)}{x'(t)})'}{x'(t)} 高阶导数求导 公式： (u \\pm v)^{(n)} = u^{(n)} \\pm v^{(n)}, (ku)^{(n)} = ku^{(n)} (uv)^{(n)}=\\Sigma_{k=0}^{n}{C_{(n)}^k u ^{(n-k)}v^{(k)})} 常用高阶导数： (e^{ax+b})^{(n)} = a^n e^{ax+b} [\\sin(ax+b)]^{(n)} = a^n \\sin(ax+b+ \\frac{n \\pi }{2}) [\\cos(ax+b)]^{(n)} = a^n \\cos(ax+b+ \\frac{n \\pi }{2}) [\\ln(ax+b)]^{(n)} = (-1)^{n-1} a^n \\frac{(n-1)!}{(ax+b)^n} (\\frac{1}{ax+b})^{(n)} = (-1)^{n} a^n \\frac{n!}{(ax+b)^{n+1}} 计算方法： 归纳法：写二阶导、三阶道再计算 当 幂函数 乘以 计算式 时候，用莱布尼茨公式 先 化简 在套用 公式 分段函数求导： 在分段点两边的导数用公式计算； 分段点用定义计算。 分段函数的导数也是分段的。 ... "},"Math/Median-Theorem.html":{"url":"Math/Median-Theorem.html","title":"微分中值定理和导数应用","keywords":"","body":"微分中值定理与导数应用 考点 在做证明等式题时： 式子中有导数项目，需要使用罗尔定理(导数的原函数端点值相等) 没有导数使用零点定理(函数端点异号)。 而证明过程需要塑造辅助函数(查看辅助函数构造方法)，把题目转化为某个函数导数的值的问题： 遇到 以下情况，需要考虑拉格朗日中值定理(在a,b区间内) f(b)-f(a) -- 可能是具体的函数(例如：\\arctan(x+1) - \\arctan(x))、也可能是抽象函数 f(x_0) = 0 这样随便在前或者在后都可以凑出定理公式 想把f(x) 、 f'(x)或者f(x) 、 f''(x)联系起来 在题中出现类拉格朗日公式，需要先用a,b先设出和表明 当有两个函数关联的时候，使用柯西中值定理 其中两个函数可以是抽象或者具体 当出现在范围中有两个存在数的时候，首先是分离函数，让两个数在等号两边 关于二阶及以上的题，不管计算或者证明，都可以使用泰勒公式，其中x_0一般是已知导数值的位置 ... 微分中值定理 罗尔定理 f(a) = f(b) 则 \\exists \\xi \\in (a,b) ，使 f'(\\xi) = 0 注： 证明难在辅助函数的寻找，看考点1、2时 计算难在证明 f(a) = f(b) **构造辅助函数常用方法：** (根据常数项是否为0区分) 观察直接进行逆推构造。 当等式中常数项为零：使用F(x) = f(x) \\cdot e^{G(x)},(其中G'(x) = g(x)) 针对 f'(x) + g(x)f(x) = 0 需要制作辅助函数的时候 ： 等式两边同乘e^{G(x)}，(其中G'(x) = g(x)) ，原式= e^{G(x)}f'(x) + g(x)e^{G(x)}f(x) = 0 最后构造出：辅助函数即为F(x) = f(x) \\cdot e^{G(x)} 注：这个题型可能要变形或者广义化使用， 如果多项式是和f'(x)乘积的时候需要等式构造上面的模式、而且f(x)可能是多项式 当等式中常数项不为零：使用常数K值法(证明拉格朗日中值定理的方法) \\exists \\xi \\in (a,b) 证明： H(a,b) = G(\\xi) 方法是： 令H(a,b) = k 化简，使其变为f(a) = f(b) 那么构造函数就是F(x)=f(x) 柯西中值定理 在g'(x)\\ne 0 时，\\exists \\xi \\in (a,b) ，使得 \\frac{f(b)-f(a)}{g(b)-g(a)} = \\frac{f'(\\xi)}{g'(\\xi)} 注：在g'(x)\\ne 0 时，根据罗尔定理可以确保g(b)-g(a) \\ne 0 ，证明可以使用反证法 拉格朗日中值定理 \\exists \\xi \\in (a,b) 使得 f(b) - f(a) = f'(\\xi)(b-a) 泰勒公式 拉格朗日余项 ：(一般是研究整体问题的时候使用，研究一个区间上的问题) f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... +\\frac{1}{n!}f^{(n)}(\\xi)(x-x_0)^n 佩亚诺余项：(一般是研究局部问题的时候使用，研究一个邻域上的问题) f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... +o((x-x_0)^n) 主要作用： 计算高阶导数 y=f(x) ，计算其中的， y = f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... 而f(x)本身如果知道泰勒公式，即可用对应指数项相同直接计算高阶导数值 .. "},"English/":{"url":"English/","title":"英语","keywords":"","body":"英语笔记 技巧 "},"English/Dictionary.html":{"url":"English/Dictionary.html","title":"词汇集","keywords":"","body":"词汇表 英文 翻译 pay attion to 对...引起注意 rudely 粗鲁的 turn aroud 环顾四周 none of your business 与你无关 theater / theatre 戏院 cinema 电影院 movie film 电影 cling film 保鲜膜 fair play 公平竞争 play a role in ... 起到..作用 slavery 奴隶制 founding generation 奠基的一代人 focus 关注 "},"English/Remember.html":{"url":"English/Remember.html","title":"背诵集合","keywords":"","body":"词汇表 英文 翻译 pay attion to 对...引起注意 rudely 粗鲁的 focus 关注 "},"English/Grammar.html":{"url":"English/Grammar.html","title":"语法","keywords":"","body":"语法 "},"CS/":{"url":"CS/","title":"专业","keywords":"","body":""},"CS/Computer-composition-principle.html":{"url":"CS/Computer-composition-principle.html","title":"计算机组成原理","keywords":"","body":""},"CS/data-structure.html":{"url":"CS/data-structure.html","title":"数据结构","keywords":"","body":"绪论 思考方法： ​ 问题驱动 \\to 三步走(绘制逻辑结构、定义存储结构、编写算法) 基本概念和术语 数据(data)—所有能输入到计算机中去的描述客观事物的符号 数值性数据 非数值性数据(多媒体信息处理) 数据元素(data element)—数据的基本单位，也称结点(node)或记录(record) 数据项(data item)—有独立含义的数据最小单位，也称域(field) 数据对象(Data Object):相同特性数据元素的集合，是数据的一个子集 数据结构(Data Structure) = 逻辑结构 + 存储结构 + 操作 定义：是相互之间存在一种或多种特定关系的数据元素的集合。 ​ 是带“结构”的数据元素的集合,“结构”就是指数据元素之间存在的关系。 ​ 是2+1 (两个层次和一个操作) 逻辑结构： 数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题 抽象出来的数学模型。（唯一） 分为4种：集合(无关系)，线性(1:1)，树(1.m)，图(m:n) 也可以划分为： 线性结构(线性表、栈、队列、串) 和 非线性结构(树、图) 存储结构(物理结构)：数据 元素 及其 关系 在计算机存储器中的存储方式。（不唯一） 分为4种：顺序(连续)，链式(不连续)，索引(字典)，散列(离散存储，效率最高) 操作(运算、行为)：执行不同功能的算法 数据类型 定义:在一种程序设计语言中,变量所具有的数据种类 抽象数据类型 (ADTs: AbstractData Types) 就是平常使用的类，ADT = ( D ,S P) 数据对象 + 数据关系 + 基本操作 更高层次的数据抽象 由用户定义,用以表示应用问题的数据模型 由基本的数据类型组成, 并包括一组相关的操作 算法和算法分析 算法定义 一个有穷的指令集,这些指令为解决某一特定任务规定了一个运算序列 算法的特性 输入、 输出、 确定性、 有穷性、 可行性 算法设计的评价 正确性、 可读性、 健壮性(鲁棒性)、 高效性(时间代价和空间代价) 算法效率的度量 算法效率的指标：时间和空间来度量 时间复杂度 空间复杂度 算法效率的度量：时间复杂度 算法效率的计算： 事后统计：利用计算机内的计时功能,不同算法的程序可以用一组或多组相同的统计数据区分 缺点: 必须先运行依据算法编制的程序 所得时间统计量依赖于硬件、软件等环境因素,掩盖算法本身的劣 事前分析估计: 一个高级语言程序在计算机上运行所消耗的时间取决于: 依据的算法选用何种策略 问题的规模 程序语言 编译程序产生机器代码质量 机器执行指令速度 时间复杂度的渐进表示法: 一般情况下,算法中基本操作重复执行的时间是问题规模 n 的某个函数 f(n),算法执行的时间的增长率和 f(n)的增长率相同,称渐近时间复杂度。 时间复杂度的表示方法有两种：大 O 法、语句频度法 T(n) = kO(C(n)) C是语句执行频次的最高次数的指数 已知时间复杂度：O(1) 算法效率的度量:空间复杂度 定义 三个组成部分 存储算法本身所占用的空间 算法的输入/输出数据占用的空间 算法在运行过程中临时占用的辅助空间 原地工作:若辅助空间相对于输入数据量是常数,则称此算法是原地工作。 说明: 若所占空间量依赖于特定的输入,按最坏情况来分析 线性表 线性结构 定义 若结构是非空有限集,则有且仅有一个开始结点和一个终端结点,并且所有结点都最多只有一个直接前趋和一个直接后继。 线性结构表达式:(a 1 ,a 2 ,......,a n ) 线性结构的特点 只有一个首结点和尾结点; 除首尾结点外,其他结点只有一个直接前驱和一个直接后继。 线性结构反映结点间的逻辑关系是一对一 线性结构包括线性表、堆栈、队列、字符串、数组等等。其中,最典型、最常用的是：线性表 线性表 类型定义 线性表的顺序存储 线性表的链式存储 重要基本操作 初始化 取值 查找 插入 删除 顺序表(顺序存储结构) 定义和实现 线性表的顺序表示又称为顺序存储结构、顺序映像、顺序表。 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简言之,逻辑上相邻,物理上也相邻 顺序存储方法：用一组地址连续的存储单元依次存储线性表的元素,可通过数组 V[n]来实现。 实现： typedef struct { ElemType *elem; //指向数据元素的基地址 int length; //线性表的当前长度 }SqList; 重要操作 初始化 //构造一个空的顺序表 L Status InitList_Sq(SqList &L) { L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0; //空表长度为 0 return OK; } //构造一个空的顺序表 指针L Status InitList_Sq(SqList *L) { L->elem=new ElemType[MAXSIZE];//为顺序表分配空间 if(! L->elem) exit(OVERFLOW); //存储分配失败 L->length=0;//空表长度为 0 return OK; } // 销毁线性表 L void DestroyList(SqList &L) { if (L.elem) delete[]L.elem; //释放存储空间 } // 清空线性表 L void ClearList(SqList &L) { L.length=0; //将线性表的长度置为 0 } // 求线性表 L 的长度 int GetLength(SqList L) { return (L.length); } // 判断线性表 L 是否为空 int IsEmpty(SqList L) { if (L.length==0) return 1; else return 0; } 取值 Status GetElem(SqList L,int i,ElemType &e) { if (iL.length) return ERROR; //判断 i 值是否合理,若不合理,返回 ERROR e=L.elem[i-1]; //第 i-1 的单元存储着第 i 个数据 return OK; } 查找 int LocateELem(SqList L,ElemType e) { for (i=0;i 插入 位置插入需要迁移的次数：n-i+1次 Status ListInsert_Sq(SqList &L,int i ,ElemType e){ if(iL.length+1) return ERROR; //i 值不合法 if(L.length==MAXSIZE) return ERROR;//当前存储空间已满 for(j=L.length-1;j>=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素 e 放入第 i 个位置 ++L.length; //表长增 1 return OK; } 步骤： 判断位置i是否合法 判断顺序表存储是否够 将第 n 至第 i 位的元素依次向后移动一个位置,空出第 i 个位置。 将要插入的新元素 e 放入第 i 个位置。 表长加 1,插入成功返回 OK。 T = O(n) ，移动次数为 n/2 删除 Status ListDelete_Sq(SqList &L,int i){ if((iL.length)) return ERROR; //i 值不合法 for (j=i;j 特点 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系,即线性表的逻辑结构与存储结构一致 在访问线性表时,可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为,访问每个元素所花时间相等，这种存取元素的方法被称为随机存取法 顺序表的优缺点： 优点: 存储密度大(结点本身所占存储量/结点结构所占存储量) 可以随机存取表中任一元素 缺点: 在插入、删除某一元素时，需要移动大量元素，浪费存储空间 属于静态存储形式,数据元素的个数不能自由扩充 链式表(链式存储结构) 定义和实现 链式存储结构： 结点在存储器中的位置是任意的,即逻辑上相邻的数据元素在物理上不一定相邻 线性表的链式表示又称为非顺序映像或链式映像。 术语 结点:数据元素的存储映像。由数据域和指针域两部分组成 链表: n 个结点由指针链组成一个链表。它是线性表的链式存储映像,称为线性表的链式存储结构 单链表、双链表、循环链表: 结点只有一个指针域的链表,称为单链表或线性链表 有两个指针域的链表,称为双链表 首尾相接的链表称为循环链表 头指针、头结点和首元结点 头指针是指向链表中第一个结点的指针 首元结点是指链表中存储第一个数据元素 a 1 的结点 头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信 息(头节点不一定存在) 如何表示空表 有头结点时，当头结点的指针域为空时 表示空表 即 head->next = null 在链表中设置头结点的好处 便于首元结点的处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致,无须进行特殊处理; 便于空表和非空表的统一处理 无论链表是否为空,头指针都是指向头结点的非空指针,因此空表和非空表的处理也就统一了。 头结点的数据域内装的是 头结点的数据域可以为空,也可存放线性表长度等附加信息,但此结点不能计入链表长度值。 实现： typedef struct LNode{ ElemType data; //数据域 struct LNode *next; //指针域 }LNode,*LinkList; // *LinkList 为 Lnode 类型的指针 LNode *p; // 上下等价 LinkList p; LNode *p 指针变量 p:表示结点地址 结点变量*p:表示一个结点 重要操作 初始化 Status InitList_L(LinkList &L) { L=new LNode; // 头节点 L->next=NULL; return OK; } // 销毁，删除所有节点，包括头节点 Status DestroyList_L(LinkList &L) { LinkList p; while(L) { p=L; L=L->next; delete p; } return OK } // 清空，把L变成空表，即头节点不变，删除其他所有节点 Status ClearList(LinkList & L) { LinkList p,q; p=L->next; //p 指向第一个结点 while(p) { q=p->next; delete p; p=q; } L->next=NULL; //头结点指针域为空 return OK; } // 求表长，返回 L 中数据元素个数 int ListLength_L(LinkList L) { LinkList p; p=L->next; i=0; while(p) { i++; p=p->next; } return i; } // 判断表是否为空，若 L 为空表,则返回 1,否则返回 0 int ListEmpty(LinkList L) { if(L->next) //非空 return 0; else return 1; } 算法步骤: 生成新结点作头结点 用头指针 L 指向头结点 头结点的指针域置空 取值 Status GetElem_L(LinkList L,int i,ElemType &e) { p=L->next; j=1; //初始化 while(p && jnext; ++j; } if(!p || j>i) return ERROR; //第 i 个元素不存在 e=p->data; //取第 i 个元素 return OK; }//GetElem_L 查找 //在线性表 L 中查找值为 e 的数据元素地址，返回 L 中值为 e 的数据元素的地址,查找失败返回 NULL LNode *LocateELem_L (LinkList L,Elemtype e) { p=L->next; while(p &&p->data!=e) p=p->next; return p; } //在线性表 L 中查找值为 e 的数据元素序号，返回 L 中值为 e 的数据元素的位置序号,查找失败返回 0 int LocateELem_L (LinkList L,Elemtype e) { p=L->next; j=1; while(p &&p->data!=e) { p=p->next; j++; } if(p) return j; else return 0; } 插入 //在 L 中第 i 个元素之前插入数据元素 e Status ListInsert_L(LinkList &L,int i,ElemType e){ p=L;j=0; while(p&&jnext; ++j; } //寻找第 i−1 个结点 if(!p||j>i−1) return ERROR; //i 大于表长+ 1 或者小于 1 s=new LNode; //生成新结点 s s->data=e; //将结点 s 的数据域置为 e s->next=p->next; //将结点 s 插入 L 中 p->next=s; return OK; }//ListInsert_L 删除 //将线性表 L 中第 i 个数据元素删除 Status ListDelete_L(LinkList &L,int i,ElemType &e){ p=L;j=0; while(p->next &&jnext; ++j; } if(!(p->next)||j>i-1) return ERROR; //删除位置不合理 q=p->next;//临时保存被删结点的地址以备释放 p->next=q->next;//改变删除结点前驱结点的指针域 // 等价于 p->next=p->next->next; e=q->data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; } //ListDelete_L 单表的建立(数据导入) // 前插法，类似堆栈，先进存在后面 void CreateList_F(LinkList &L,int n) { L=new LNode; L->next=NULL; //先建立一个带头结点的单链表 for(i=n;i>0;--i) { p=new LNode; //生成新结点 cin>>p->data; //输入元素值 p->next=L->next; L->next=p; //插入到表头 } }//CreateList_F // 尾插法，正位序输入 n 个元素的值,建立带表头结点的单链表 L void CreateList_L(LinkList &L,int n){ L=new LNode; L->next=NULL; r=L; //尾指针 r 指向头结点 for(i=0;i>p->data; //输入元素值 p->next=NULL; r->next=p; //插入到表尾 r=p; //r 指向新的尾结点 } }//CreateList_L 循环链表 和单链不同，循环链表的遍历循环条件： p!=L p->next!=L // 两个循环链表的合并 LinkList Connect(LinkList Ta,LinkList Tb) // 假设 Ta、Tb 都是非空的单循环链表 { p=Ta->next; //p 存表头结点 Ta->next=Tb->next->next; //Tb 表头连结 Ta 表尾 deleteTb->next; //释放 Tb 表头结点 Tb->next=p; //修改指针 returnTb; } 双向链表 // 定义 typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode, *DuLinkList; // 插入 Status ListAdd_DuL(DuLinkList &L,int i,ElemType &e){ if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p->data; p->prior->next=p->next; p->next->prior=p->prior; delete p; return OK; } // 删除 Status ListDelete_DuL(DuLinkList &L,int i,ElemType &e){ if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p->data; p->prior->next=p->next; p->next->prior=p->prior; delete p; return OK; } . 特点 链表的优缺点 优点 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据,只需修改链接指针,修改效率较高 缺点 存储密度小 存取效率不高,必须采用顺序存取,即存取数据元素时,只能按链表的顺序进行访问(顺藤摸瓜) 链表的运算时间效率分析 查找:因线性链表只能顺序存取,即在查找时要从头指针找起,查找的时间复杂度为 O(n)。 插入和删除:因线性链表不需要移动元素,只要修改指针,一般情况下时间复杂度为 O(1)。 但是,如果要在单链表中进行前插或删除操作,由于要从头查找前驱结点,所耗时间复杂度为 O(n) 。 "},"CS/operating-system.html":{"url":"CS/operating-system.html","title":"操作系统","keywords":"","body":"概念 操作系统(OS)也叫做 系统软件 OS作为计算机系统资源的管理者 OS用作扩展机、虚拟机 OS作为用户和计算机硬件系统的接口 接口形式： 系统调用 -- 用于编程 命令输入 (命令行、GUI、NUI(语音识别)) -- 用于交互控制 ... 考点 和硬件相关(组成原理)的东西都不是操作系统管的 .. 操作系统的特征、功能和提供的服务 基本特征(四大特征) 并发(Concurrence) -- 基本特征 并行是多个事件在同一时刻发生，并发是多个事件在同一时间段内发生；当时间段无限趋近0的时候并发即为并行。 计算机是顺序执行的，所以计算机处理问题是并发的； 共享(Sharing) 虚拟(Virtual) 异步性(Asynchronism) 多个进程“走走停停“，一起执行 由于上述特征导致程序失去 封闭性 功能(管理和分配资源) 进程管理(进程与线程) 存储管理(内存管理) 文件管理(文件系统) 输入输出管理(设备管理) 作业管理(大型计算机) 操作系统提供的服务(接口) 公共服务(用命令控制计算机) 系统调用服务(各个功能模块) 操作系统的发展与分类 操作系统的发展 从无到有 从简单到复杂 从单机到联网 从专用到通用再到专用 操作系统的分类 无操作系统的人工操作方式 脱机输入/输出(Off-Line I/O)方式——monitor 单用户操作系统 (OS) 单/多道批处理系统(大型计算中心) 分时系统(通用交互式系统) 实时系统(工控/军事) 网络操作系统(增加了资源共享和通信功能) 分布式操作系统(用户透明/强壮) 并行操作系统 (高效) 操作系统的运行环境 内核态与用户态 用户态只能用自己的资源，内核态只能访问系统资源，他们是用户态调用内核态的关系，而这个调用时候使用的就是访管指令 内核态与用户态是指进程(线程)在执行代码过程中为了安全保护而设置的二个不同的阶段。 内核态可以执行所有的系统代码，包括特权指令 而用户态只能执行用户的代码。 若用户需要执行特权代码时，必须发起一次系统调用。 中断、异常 中断(interrupt)是指处理机对系统中或系统外发生的异步事件的响应。 异常(陷阱 trap)是指由系统发起的一次确定的服务过程(也称为软中断)、也算用户态转为内核态的访管指令 访管指令(用户态转为内核态的指令) 不是 特权指令(处理器对内核的特殊操作) 用户从用户态进入内核态必定通过访管指令 从内核态返回用户态可以修改状态字实现 系统调用 系统调用是指当用户需要使用某些计算机资源时，因为这些资源是被操作系统所控制的，用户不能直接使用该资源，而是必须向操作系统提出“请求”，由操作系统安排合理、高效、安全地使用这些资源 这种“请求”便称为系统调用 这种“请求”的格式通常是指令名加上请求的服务识别号(有时是中断号) 操作系统体系结构 单一结构(小型嵌入式) 分层结构(用户层/内核下层/内核上层) 客户/服务器结构(微内核) 虚拟机结构(容器) 进程管理 进程与线程 进程概念 一个具有一定独立功能的程序对某个数据集合上的一次动态执行过程和资源分配过程 进程包含的重要元素: 代码(指令) Code 数据 Data 进程表(进程控制块) PT(PCB) 唯一标志 进程和程序的区别与联系 进程是动态的，程序是静态的 进程是暂时的，程序是永久的 进程和程序的组成不同： 程序主要包含代码和数据 进程除了包含代码和数据以外，还有进程表 进程和程序间有非常紧密的联系 程序经过多次创建，可以对应不同的进程 一个进程通过系统调用，可以被多个程序所使用 进程的状态与转换 三种基本状态 就绪(Ready)状态 执行(Running)状态 阻塞(Blocking)状态 四种转换 执行——>阻塞(出事) 执行——>就绪(时间到) 就绪——>执行(调度) 阻塞——>就绪(事毕) 五状态模型（三基础模型上） 创建(create) 终止(terminal) 七状态模型（五状态模型上） 就绪挂起(Ready Suspend) 阻塞挂起(Blocked Suspend) 挂起即为把资源从内存放到外面 进程控制 进程的创建(创建原语) 进程的创建过程 申请空白进程表 为新进程分配资源 初始化进程表 将新进程插入就绪队列 进程的终止 正常结束(自愿的) 异常结束 出现错误控制退出(自愿的) 致命错误被迫退出(非自愿的) 外界干预(非自愿的) 进程的终止过程 从进程控制块中读出该进程的状态 若被终止进程正处于执行状态，立即终止该进程的执行 若该进程还有子孙进程，还应将其所有子孙进程予以终止 将被终止进程所拥有的全部资源，或者归还给其父进程， 或者归还给系统 将被终止进程的进程控制块移出 进程的阻塞与唤醒的出发原因 请求系统服务 启动某种操作 新数据尚未到达 无新工作可做 进程的挂起与激活 进程组织 进程表中的信息 进程管理信息: 进程号，处理器寄存器，优先级等 存储资源分配: 代码指针，数据指针，堆和栈的指针等 文件资源信息: 句柄，描述符，设备等 链接方式 就绪队列链表(一般为一个) 阻塞队列链表(可能依据不同阻塞原因有多个队列链表) 索引方式 就绪队列索引 阻塞队列索引 ... 进程通信 Shared memory(共享内存) 共享某些数据结构(有名) 共享内存区域(指针) Message(消息机制) 发送原语 send(receiver，message) 接收原语 receive(sender，message) 异步实现 Pipe(管道) 原语自动实现同步 实现阻塞读，非阻塞读或阻塞写或非阻塞写 实现方法 read/write，不支持 lseek Signal(信号) Socket(套接字) 线程概念与多线程模型 线程概念：提高并发性 进程是实体。 资源分配目标是进程、调度分派优先是线程 线程的属性 轻型实体(容易创建和撤销) 独立调度和分派的基本单位 可并发执行 共享进程资源 适应硬件的发展 在具有线程 OS 中，进程是作为拥有系统资源的基本单位， 进程不再作为一个执行的实体。 具有线程的 OS 中的进程有以下属性: 作为系统资源分配的单位 可包括多个线程 进程变为了不是一个可执行的实体 线程间的同步和通信 互斥锁(mutex):互斥锁是一种比较简单的、用于实现线程间对资源互斥访 问的机制 条件变量 线程共享同一进程的全局变量 内核支持线程 内核支持线程是在内核的支持下运行的，即无论是用户进程中的线程， 还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实 现的。 在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根 据该控制块而感知某线程的存在的，并对其加以控制 处理机调度 调度的基本概念 作业调度——进入内存(宏观调度/高级调度) 进程/线程调度——占用处理器(微观调度/低级调度) 交换调度——位于何处(中级调度) 高级调度(High Scheduling)，宏观调度，作业调度 在每次执行作业调度时(由外存创建到内存成为进程)，都须做出以下两个决定: 接纳多少个作业 接纳哪些作业 中级调度(Intermediate-Level Scheduling) ，中程调度 引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量 中级调度的算法主要由内存管理来实现，与高级调度和低级调度的算法不同 故一般在存储管理中分析，虚拟存储的中级调度即页面调入、置换等实现 低级调度(Low Level Scheduling)，微观调度，进程调度，线程调度 调度的方式: 非抢占方式(Non-preemptive Mode) 抢占方式(Preemptive Mode)... 调度时机、切换与过程 时机、切换 调度器(scheduler)/切换器(dispatcher 也称分派器)(均是系统代码级程序) 策略与机制 调度队列 上下文(context)切换 过程(例如:分时系统) 时钟中断，响应，时间片到(时机) 激活调度器，调度器占用 CPU 运行(很少代码很短时间)，按照调度算法选出下一个运行的进程 激活切换器，切换器占用 CPU 运行(很少代码很短时间)，将原处理器上进程撤下，将新进程装入 将 CPU 交由新进程运行 调度的基本准则 公平 策略执行 平衡 调度方法 典型调度算法 "},"CS/computer-network.html":{"url":"CS/computer-network.html","title":"计算机网络","keywords":"","body":""}}