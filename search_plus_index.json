{"./":{"url":"./","title":"介绍","keywords":"","body":"考研笔记 源位置： GitHub 加速网址：国内地址 感悟想法 沟通 \\iff 传输 + 回馈 When Who in Where do What for Why, and How to delelte 生活数学式 (1.01)^{365} = 37.8 , (1.02)^{365} = 1377.4 (0.09)^{365} = 0.03 , (0.98)^{365} = 0.0002 积少成多，流沙易逝，所有的成败都取决于一个坚持，坚持积累，坚持不放纵自己才能成功。 \\lim_{t->now}{过程} = 行动 当时间无限趋近现在这个时间点，所谓过程 就是 当前做的行动 (过程 + 过去)' = 行动的结果 \\int (结果) + 过去 = 过程 过去 是一个常量 ， 而 整个进行了的过程​ 的导数(趋势) 就必然指向了​未来的结果 ， 而累计的无数已行结果 的积分就是 整个过程 综1、2上： 任何漫长的过程，都是无数有作为的行动组成的； 过程和结果没有重要性区别，已行过程决定未来结果，已有结果组成整个过程。 问题分析的泰勒公式 问自己一次 why 即一个高阶求导，公式如下： 问题 = Why + \\frac{Why(Why)}{1!} + \\frac{Why(Why(Why))}{2!} + \\frac{Why(Why(Why(Why)))}{3!} ... + o(why^n) (余项即累计经验) 反复问自己：\"这是为什么\"；得出结论后，在问：\"这又是为什么\" ，不断循环，就能分析清楚，而累计的经验即余项； 越多次反问、越丰富经验，就能更接近真相。 "},"Political/":{"url":"Political/","title":"政治","keywords":"","body":"政治总结 "},"Political/Marxism.html":{"url":"Political/Marxism.html","title":"马克思主义基本原理","keywords":"","body":"马原 马原基本三部曲：昨天 - 今天 - 明天 通过分许过去得出：时代在进步，未来在发展，人民来推动 -> 马哲 通过批判今天得出：资本主义必然灭亡 -> 政经 通过指明未来得出：社会主义必然胜利 -> 科社 历史背景 社会根源： 资本主义的发展及其内在矛盾激化 1837年，第一个无产阶级政党： 共产主义同盟 马恩实践上的贡献：积极投身工人运动中 马恩理论上的贡献：洗手德国古典哲学、英国古典政治经济学、英法的空想社会主义合理成分 根本原因 因为 1. 资本主义的发展及其内在矛盾激化 (时势造英雄) 成立标志 1848年，马克思发表了《共产党宣言》 马克思主义俄国化 理论发展：提出社会主义革命可能在一个国家先发生 实践探索：十月革命，把社会主义从理论变成实践，建立第一个社会主义制度 马克思是把空想变成理论，列宁把理论变为实践 马克思主义当代最新理论成果 最新成果是：习近平新时代中国特色社会主义思想 其是党和人民实践经验和集体智慧的结晶 内涵和特征 内涵 马克思主义是由马恩创立，尤其后各个时代、民族的马克思主义者丰富和发展的观点和学说体系 研究对象： 关于自然、社会和人类思维的学说 目的： 关于社会主义必然取代自办主义，最终实现共产主义的学说 意义：关于无产阶级解放、全人类解放和每个人自由而全面发展的学说 理论体系 马克思主义哲学、马克思主义政治经济学、科学社会主义 哲学：理论基础 政经：现实运用 科社：方向、核心和目的 "},"Math/":{"url":"Math/","title":"高数","keywords":"","body":"高数总纲 基础知识点 二倍角公式、诱导公式、扩角公式 注意： 在设计三角函数的相关题目中，\\cos{x}\\cos{x} \\pm \\sin{x}\\sin{x} 等要常常化简，化简后再运算。 复合求导计算公式 基础求导 \\begin{array}{|c|c|} \\hline (a^x)' ={lna} \\cdot a^x & (log_{a}{x})'=\\frac{1}{xlna}\\\\ \\hline (x^x)' = x^x(1+lnx) & ln'(x+\\sqrt{1+x^2}) = \\frac{1}{\\sqrt{1+x^2}}\\\\ \\hline \\tan'(x) = \\frac{1}{\\cos^2(x)} = \\sec^2(x) & \\cot'(x) = -\\frac{1}{\\sin^2(x)} = -\\csc^2(x) \\\\ \\hline \\sec'(x) = \\sec(x)\\tan(x) & \\csc'(x) = -\\csc(x)\\cot(x) \\\\ \\hline \\arcsin'(x) = \\frac{1}{\\sqrt{1-x^2}} & \\arccos'(x) = -\\frac{1}{\\sqrt{1-x^2}} \\\\ \\hline \\arctan'(x) = \\frac{1}{1+x^2} & \\arccos'(x) = -\\frac{1}{1+x^2} \\\\ \\hline arcsec'(x) = \\frac{1}{\\vert{x}\\vert\\sqrt{x^2-1}} & arccsc'(x) = -\\frac{1}{\\vert{x}\\vert\\sqrt{x^2-1}} \\\\ \\hline \\end{array} 基础不等式 \\frac{a+b}{2} \\ge \\sqrt{ab} \\Rightarrow \\frac{a_1+a_2..a_n}{n} \\ge \\sqrt[n]{a_1 \\cdot a_2 ... \\cdot a_n} ... ... "},"Math/Limit.html":{"url":"Math/Limit.html","title":"极限","keywords":"","body":"极限相关知识 考点 对求极限中，需要 分左右极限 考虑问题： 存在分段点(带有绝对值的、分段函数) e^\\infty 类型： e^+\\infty \\rightarrow +\\infty，e^-\\infty \\rightarrow 0 \\arctan(\\infty) 类型 ， \\arctan(+\\infty) = \\pi/2 ， \\arctan(-\\infty) = -\\pi/2 f(x)在(a,b) 连续 ，且\\lim_{x \\rightarrow a^+}{f(x)}和\\lim_{x \\rightarrow b^-}{f(x)} 存在 ，f(x)在(a,b) 有界。 f(x)在[a,b] 连续，f(x)在[a,b]有界。 若\\lim{f(x)}存在 ，\\lim{g(x)}不存在 ，则\\lim{f(x) \\pm g(x)} 一定不存在 若\\lim{f(x)}不存在 ，\\lim{g(x)}不存在 ，则\\lim{f(x) \\pm g(x)} 不一定存在 综上： 2存在\\Rightarrow 存在 || 1存在1不存在\\Rightarrow 不存在 || 2不存在\\Rightarrow 不确定 存在性质： 夹逼准则：当 分子分母都在动，需要预估上下限，使用夹逼准则，动分子不动分母 (求和不用通分) 单调有界 \\Rightarrow 有极限 ：证明单调性可以用归纳法证明单调性 无穷小性质： 无穷小 与 有界变量乘积 的乘积还是无穷小，即\\lim = 0 知道某极限为0可以，进行计算某函数的表达式 \\lim{f(x)} =0 \\Rightarrow f(x) = 0+ \\alpha (\\alpha为无穷小) x \\to +\\infty ，时候，判定级别大小： \\ln^{\\alpha}x 小 除 大 值是：无穷小 求极限 链接 注意点： 先 变形(又加减幂指转为乘除) 化简 再用 公式 ** x \\sim \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 只有 乘除 才可以使用 等价无穷小 、先计算一部分不为0的部分 ** 只有 拆分极限后两个极限都存在 的时候才可以使用 极限运算法则 ** 针对 幂指函数 问题，需要先判断 底数 极限是 0或1 题型分析： e^{f(x)} - e^{g(x)} = e^{g(x)} [e^{f(x)-g(x)} - 1] \\sim [{f(x)-g(x)}] \\cdot e^{g(x)} 分子为 两根式相加减 ，先 有理化 ，而一般提出那部分不是0，可以先算出来： \\lim{\\sqrt\\alpha - \\sqrt\\beta} = \\lim{(\\alpha - \\beta) \\frac{1}{\\sqrt\\alpha + \\sqrt\\beta}} 题目中有 \\frac{1}{x} ,使用倒代换，令t=\\frac{1}{x} \\lim{(\\tan(x) - \\sin(x))} = \\lim{(\\tan(x)(1-\\cos(x))} = \\lim{(\\frac{x^3}{2})} 合1、3： \\lim{(e^{\\tan(x)} - e^{\\sin(x)})} = lim{\\frac{x^3e^{\\sin(x)}}{2}} u(x)^{v(x)} == e^{v(x)\\ln{u(x)}} 由此变形幂指处理为乘除问题，注意u(x) 极限是否为1(查看题型6)； \\ln'(x+\\sqrt{1+x^2}) = \\frac{1}{\\sqrt{1+x^2}} ** 求1^{\\infty}类型时候，其 \\lim{u(x)} = 1 , \\lim{v(x)} = \\infty ，所以可以直接用 \\lim{u(x)^{v(x)}} = \\lim{e^{v(x)[u(x)-1]}} 泰勒公式 题型分析： 分式模式，且分母是多项式 泰勒公式展开式达到什么级别即可，展开达到 分母的指数 即可 两个可拆分泰勒公式加减 的时候，展开达到 第一次同次方 系数不能抵消 数列求极限： 题型分析： 无限项和 求极限：找数列中的 最大项、最小项，做夹逼准则：\\lim{n \\cdot a_1} \\le \\lim{a_1..a_n} \\le \\lim{n \\cdot a_n} 有限项和 求极限：只找有限数列中的 最大项 (可以假设某项为最大)，做夹逼准则：\\lim{n \\cdot a_{max}} \\le \\lim{n \\cdot (a_1..a_m)} \\le \\lim{n \\cdot m \\cdot a_{max}} ** \\lim_{n \\to \\infty}{\\sqrt[n]{a_1^n+a_2^n..a_m^n}} = max(a_1,a_2..,a_m) ... 求函数间断点，再求左右极限 (看考点1)，最后确认间断点类型： 无定义点 分段点 确认间断点类型，分四种情况： 左极限 = 右极限 = 函数值 \\Rightarrow 连续 左极限 = 右极限 \\ne 函数值 \\Rightarrow 可去间断点 左极限 \\ne 右极限 \\Rightarrow 跳跃间断点 左右某个极限不存在 \\Rightarrow 第二间断点 复杂f(b)-f(a)相关极限问题，可以使用 拉格朗日中值定理 解决 .... 邻域 区间 (x_0 - \\delta , x_o + \\delta ) 称为x_0 在\\delta 邻域，去掉x_0 称为去心邻域 \\delta 称为邻域半径(这个值会很小) 极限定义 对一个点的极限 -\\delta 且 x \\neq x_0 , |f(x)-a| , \\varepsilon , \\delta 无限小 称为x \\rightarrow x_0 的极限为a 记：\\lim_{x \\rightarrow x_0}{f(x)} = a 单侧极限： \\lim_{x\\rightarrow x_0^-}{f(x)} 左极限 \\lim_{x\\rightarrow x_0^+}{f(x)} 右极限 定理： \\lim_{x \\rightarrow x_0}{f(x)} = a \\iff \\lim_{x\\rightarrow x_0^-}{f(x)}= \\lim_{x\\rightarrow x_0^+}{f(x)} = a 对无限的极限 |x| , |f(x)-a| , \\varepsilon 无限小, X 无限大 称为x \\rightarrow \\infty 的极限为a 记：\\lim_{x \\rightarrow \\infty}{f(x)} = a 单侧极限： \\lim_{x\\rightarrow -\\infty}{f(x)} 左极限 \\lim_{x\\rightarrow +\\infty}{f(x)} 右极限 定理2： \\lim_{x \\rightarrow \\infty}{f(x)} = a \\iff \\lim_{x\\rightarrow -\\infty}{f(x)}= \\lim_{x\\rightarrow +\\infty}{f(x)} = a 性质 一般性质 唯一性： 极限存在即唯一 局部有界性： 极限存在具体值，则f(x) 在x \\rightarrow x_0 有界 ** 极限正、函数正 | 极限负、函数负 运算性质 设 \\lim{f(x)}=A(\\exists) ,\\lim{g(x)}=B(\\exists) \\lim{f(x)\\pm g(x)}=\\lim{f(x)} \\pm \\lim{g(x) = A \\pm B} \\lim{f(x). g(x)}=\\lim{f(x)} . \\lim{g(x) = A . B} \\lim{\\frac {f(x)}{g(x)}}= \\frac{\\lim{f(x)}}{\\lim{g(x)}} = \\frac{ A }{B} 存在性质 夹逼准则： x_n \\leq y_n \\leq z_n , \\lim_{n\\to\\infty}{x_n}=\\lim_{n\\to\\infty}{z_n}=a 则 \\lim_{n\\rightarrow\\infty}{y_n}=a 单调增有上界的数列、单调减有下界的数组 \\Rightarrow 数组有极限 无穷小 无穷小定义 \\lim_{x \\to x_o}{f(x)} = 0 时，f(x) 为 x \\to x_0时的无穷小 无穷小比较 高阶 若\\lim{\\frac{\\alpha}{\\beta}} = 0 ，称 \\alpha 是 \\beta 的高阶无穷小，记： \\alpha = o(\\beta) 同阶 若\\lim{\\frac{\\alpha}{\\beta}} = C \\ne 0 ，称 \\alpha 是 \\beta 的同阶无穷小 等价 若\\lim{\\frac{\\alpha}{\\beta}} = 1 ，称 \\alpha 是 \\beta 的等价无穷小 无穷小性质 ** 无穷小 与 有界变量乘积 的乘积 为无穷小 有限个 无穷小 的 乘积(和) 为无穷小 无限个 无穷小 的 乘积(和) 不一定为无穷小 极限与无穷小的关系 \\lim_{x \\to *}{f(x)} = a \\iff f(a) = a + \\beta 则 其中 \\beta 是 x \\to * 时的无穷小 求极限(七种类型) \\frac{0}{0} 类型 方法： 等价代换、洛必达、泰勒公式 1. 常用等价无穷小 x \\sim \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 1-\\cos(x) \\sim \\frac{1}{2}x^2 (1+x)^a -1 \\sim ax a^x -1 \\sim x\\ln{a} \\Rightarrow e^x -1 \\sim x 重点等价无穷小 ( x - x等价项 )： x 的等价项： \\sin(x) \\sim \\arcsin(x) \\sim \\tan(x) \\sim \\arctan(x) \\sim ln(1+x) \\sim e^{x}-1 x-\\sin(x) \\sim \\frac{x^3}{6} \\Rightarrow \\arcsin(x) - x \\sim \\frac{x^3}{6} \\tan(x) - x \\sim \\frac{x^3}{3} \\Rightarrow x - \\arctan(x) \\sim \\frac{x^3}{3} x - \\ln(1+x) \\sim \\frac{x^2}{2} 注 ： x 可以是 f(x) ， 只要 f(x) \\to 0 即可 只有乘除才可以使用等价无穷小 2. 洛必达法则 当 \\lim_{x \\to x_o}{f(x)}=\\lim_{x \\to x_o}{g(x)}=0 或者 \\infty 时： \\lim_{x \\to x_o}{\\frac{f(x)}{g(x)}} = \\lim_{x \\to x_o}{\\frac{f'(x)}{g'(x)}} \\frac{\\infty}{\\infty} 类型 方法：洛必达法则、分子分母同除最大量、抓大头 抓大头： 极限中出现 \\infty - 0 ，可以选择不理会 0 的项式 注： 遇到题目先考虑洛必达法则 当 x \\to - \\infty 时候，x为负数，开跟等要有负号 0 \\cdot \\infty 类型 方法：化为 \\frac{0}{0} 或者 \\frac{\\infty}{\\infty} 注： 一般 对数 、反三角 作分子 \\lim_{x \\to 0}{x \\ln(x)} = 0 \\infty - \\infty 方法： 通分、有理化、倒带换 化为 \\frac{0}{0} 或者 \\frac{\\infty}{\\infty} 注： 题目中有 \\frac{1}{x} ,使用倒代换，令t=\\frac{1}{x} 0^0,\\infty^0 类型 方法：变形为乘除 u(x)^{v(x)} == e^{v(x)\\ln{u(x)}} 1^{\\infty}类型 方法：\\lim{u(x)^{v(x)}} = \\lim{e^{v(x)[u(x)-1]}} 计算过程： \\lim{u(x)^{v(x)}} = \\lim{e^{v(x)\\ln[1+u(x)-1]}} = \\lim{e^{v(x)[u(x)-1]}} 运用等价代换 \\ln(x) \\sim x 泰勒公式 通式： f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + \\frac{1}{3!}f^{(3)}(x_0)(x-x_0)^3 + .... +\\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n + o(x^n) f(x) = f(0) + f'(0)x + \\frac{1}{2!}f''(0)x^2 + \\frac{1}{3!}f'''(0)x^3 + o(x^3) (麦克劳林公式) 注： o(x^2)是x^2的无穷小值，故 o(x^2) \\pm o(x^2) = o(x^2) , 且 \\lim{o(x^2)} = 0 o(x^m) \\pm o(x^n) = o(x^{\\max{(m,n)}}) o(x^m) \\cdot o(x^n) = o(x^{(m+n)}) 通项拆分指南： 分式模式，且分母是多项式 泰勒公式展开式达到什么级别即可，展开达到 分母的指数 即可 两个可拆分泰勒公式加减 的时候，展开达到 第一次同次方 系数不能抵消 考纲必用-泰勒公式 \\sin{x} = x - \\frac{1}{3!}x^3 + o(x^3) \\cos{x} = 1 - \\frac{1}{2!}x^2 + \\frac{1}{4!}x^4 + o(x^4) \\arcsin{x} = x + \\frac{1}{3!}x^3 + o(x^3) \\tan{x} = x + \\frac{1}{3}x^3 + \\frac{2}{15}x^5 + o(x^5) \\arctan{x} = x - \\frac{1}{3}x^3 + \\frac{1}{5}x^5 + o(x^5) \\ln(1+x) = x - \\frac{1}{2}x^2 + \\frac{1}{3}x^3 + o(x^3) e^x = 1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 + o(x^3) (1+x)^a = 1 + ax + \\frac{a(a-1)}{2!}x^2 + o(x^2) \\frac{1}{1-x}=1+x+x^2+x^3+o(x^3) 数列求极限 求n项和的极限 方法： 先求和、夹逼准则、定积分 记忆：\\lim_{n \\to \\infty}{\\sqrt[n]{a_1^n+a_2^n..a_m^n}} = max(a_1,a_2..,a_m) 夹逼准则注： 无限项和 求极限：找数列中的 最大项、最小项，做夹逼准则： \\lim{n \\cdot a_1} \\le \\lim{a_1..a_n} \\le \\lim{n \\cdot a_n} 有限项和 求极限：只找有限数列中的 最大项 (可以假设某项为最大)，做夹逼准则： \\lim{n \\cdot a_{max}} \\le \\lim{n \\cdot (a_1..a_m)} \\le \\lim{n \\cdot m \\cdot a_{max}} 由递推公式计算极限 方法：单调有界准则 具体方法： 证明单调性及其对应的上界或下界 (可以先求好证的拿分) 令\\lim{x_n} = A，则\\lim{x_{n+1}} = A (极限存在则唯一) ， 在递推公式两边同时取极限 连续和间断 定义1：若y=f(x)在x_0的领域内有定义，则\\lim_{x \\to x_0}{f(x)} = f(x_0) \\iff y=f(x) 在x_0处连续 定义2：若y=f(x)在x_0的去心领域内有定义，则y=f(x) 在x_0处不连续 ，x_0是f(x) 的间断点 间断点分类 第一类间断点：左右极限 都存在 可去间断点：左右极限 存在且相等 跳跃间断点：左右极限 存在但不等 第二类间断点：左右极限 至少一个不存在 连续函数规则 f(x),g(x)在x=x_0连续，则f(x) \\pm g(x) , f(x) \\cdot g(x)都连续； 当g(x_0) \\ne 0时候，\\frac{f(x)}{g(x)}连续 y=f(u),u=\\varphi(x)在u=u_0连续，则f(\\varphi(x))连续； y=f(x)单调连续，则x=\\varphi(y)连续 连续函数性质 闭区间下才成立 有界 有最大最小值 介值定理：介于最小、最大值之间的任意数\\mu，必然\\exists \\alpha 在闭区间内，使得f(\\alpha)=\\mu 零点定理：若f(x)在[a,b]之间连续，且f(a) \\cdot f(b) ，则存在f(\\mu)=0 "},"Math/Derivatives-Integrals.html":{"url":"Math/Derivatives-Integrals.html","title":"导数与积分","keywords":"","body":"导数 考点 分段函数 求左导数、右导数，必须严格使用 定义 计算 分析 一个点的导数 问题，用 定义 处理 参数方程的二次导数(证明过程看下面导数计算)： y'' =\\frac{(\\frac{y'(t)}{x'(t)})'}{x'(t)} 计算高阶导的时候，只有当u 、 v的某个导数 (幂函数) 可以迅速为0的时候使用莱布尼茨公式 ... 导数定义 定义1：导数： f'(x_0) = \\lim_{\\Delta x \\to 0}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 若极限存在，导数存在； 若极限不存在，导数不存在。 注： \\Delta x 必须可正可负 导数定义另一形式：f'(x_0) = \\lim_{x \\to x_0}{\\frac{f(x) - f(x_0)}{x-x_0}} 导数定义中分子必须出现“ - f(x_0) ” 定义2：左导数：f_-'(x_0) = \\lim_{\\Delta x \\to 0^-}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 定义3：右导数：f_+'(x_0) = \\lim_{\\Delta x \\to 0^+}{\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}} 定理：f'(x_0) = A \\iff f_-'(x_0) = f_+'(x_0) = A 导数几何意义 导数即是函数的切线斜率 切线方程： y - f(x_0) = f'(x_0)(x-x_0) 法线方程： y - f(x_0) = -\\frac{1}{f'(x_0)}(x-x_0) (f'(x_0) \\ne 0 ) 微分定义 \\Delta y = A \\Delta x , A 是常数 则y = f(x)可微，而dy = A \\Delta x称为微分 定理：y=f(x) 在x=x_0上，可微 \\iff 可导 ，且dy = f'(x)dx 微分几何意义 局部的“以取代直”，用y = dy + y_0 切线近似代替曲线y=f(x) 微分：dy 是切线在 横坐标\\Delta x内的 纵坐标改变量 ​ 而真实曲线纵坐标改变量是 \\Delta y ，当\\lim{\\Delta x} = 0时，dy = \\Delta y 连续、可导、可微 连续未必可导 可导一定连续 可导等价可微 导数计算 基础 ... 反函数求导： x_y' = \\frac{1}{y_x'} 隐函数求导： F(x-y) = 0，两端对 x 求导，得y' 参数方程求导：y' = \\frac{y'(t)}{x'(t)} 参数方程的二次导数： y'' = \\frac{d^2y}{dx^2} = \\frac{d}{dx}(\\frac{dy}{dx}) = \\frac{d}{dx}(\\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}) = \\frac{d}{dx}(\\frac{y'(t)}{x'(t)}) = \\frac{\\frac{d(\\frac{y'(t)}{x'(t)})}{dt}}{\\frac{dx}{dt}} = \\frac{(\\frac{y'(t)}{x'(t)})'}{x'(t)} 高阶导数求导 公式： (u \\pm v)^{(n)} = u^{(n)} \\pm v^{(n)}, (ku)^{(n)} = ku^{(n)} (uv)^{(n)}=\\Sigma_{k=0}^{n}{C_{(n)}^k u ^{(n-k)}v^{(k)})} 常用高阶导数： (e^{ax+b})^{(n)} = a^n e^{ax+b} [\\sin(ax+b)]^{(n)} = a^n \\sin(ax+b+ \\frac{n \\pi }{2}) [\\cos(ax+b)]^{(n)} = a^n \\cos(ax+b+ \\frac{n \\pi }{2}) [\\ln(ax+b)]^{(n)} = (-1)^{n-1} a^n \\frac{(n-1)!}{(ax+b)^n} (\\frac{1}{ax+b})^{(n)} = (-1)^{n} a^n \\frac{n!}{(ax+b)^{n+1}} 计算方法： 归纳法：写二阶导、三阶道再计算 当 幂函数 乘以 计算式 时候，用莱布尼茨公式 先 化简 在套用 公式 分段函数求导： 在分段点两边的导数用公式计算； 分段点用定义计算。 分段函数的导数也是分段的。 ... "},"Math/Median-Theorem.html":{"url":"Math/Median-Theorem.html","title":"微分中值定理和导数应用","keywords":"","body":"微分中值定理与导数应用 考点 在做证明等式题时： 式子中有导数项目，需要使用罗尔定理(导数的原函数端点值相等) 没有导数使用零点定理(函数端点异号)。 而证明过程需要塑造辅助函数(查看辅助函数构造方法)，把题目转化为某个函数导数的值的问题： 遇到 以下情况，需要考虑拉格朗日中值定理(在a,b区间内) f(b)-f(a) -- 可能是具体的函数(例如：\\arctan(x+1) - \\arctan(x))、也可能是抽象函数 f(x_0) = 0 这样随便在前或者在后都可以凑出定理公式 想把f(x) 、 f'(x)或者f(x) 、 f''(x)联系起来 在题中出现类拉格朗日公式，需要先用a,b先设出和表明 当有两个函数关联的时候，使用柯西中值定理 其中两个函数可以是抽象或者具体 当出现在范围中有两个存在数的时候，首先是分离函数，让两个数在等号两边 关于二阶及以上的题，不管计算或者证明，都可以使用泰勒公式，其中x_0一般是已知导数值的位置 奇函数只有奇数次级的导数 ... 微分中值定理 罗尔定理 f(a) = f(b) 则 \\exists \\xi \\in (a,b) ，使 f'(\\xi) = 0 注： 证明难在辅助函数的寻找，看考点1、2时 计算难在证明 f(a) = f(b) **构造辅助函数常用方法：** (根据常数项是否为0区分) 观察直接进行逆推构造。 当等式中常数项为零：使用F(x) = f(x) \\cdot e^{G(x)},(其中G'(x) = g(x)) 针对 f'(x) + g(x)f(x) = 0 需要制作辅助函数的时候 ： 等式两边同乘e^{G(x)}，(其中G'(x) = g(x)) ，原式= e^{G(x)}f'(x) + g(x)e^{G(x)}f(x) = 0 最后构造出：辅助函数即为F(x) = f(x) \\cdot e^{G(x)} 注：这个题型可能要变形或者广义化使用， 如果多项式是和f'(x)乘积的时候需要等式构造上面的模式、而且f(x)可能是多项式 当等式中常数项不为零：使用常数K值法(证明拉格朗日中值定理的方法) \\exists \\xi \\in (a,b) 证明： H(a,b) = G(\\xi) 方法是： 令H(a,b) = k 化简，使其变为f(a) = f(b) 那么构造函数就是F(x)=f(x) 柯西中值定理 在g'(x)\\ne 0 时，\\exists \\xi \\in (a,b) ，使得 \\frac{f(b)-f(a)}{g(b)-g(a)} = \\frac{f'(\\xi)}{g'(\\xi)} 注：在g'(x)\\ne 0 时，根据罗尔定理可以确保g(b)-g(a) \\ne 0 ，证明可以使用反证法 拉格朗日中值定理 \\exists \\xi \\in (a,b) 使得 f(b) - f(a) = f'(\\xi)(b-a) 泰勒公式 拉格朗日余项 ：(一般是研究整体问题的时候使用，研究一个区间上的问题) f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... +\\frac{1}{n!}f^{(n)}(\\xi)(x-x_0)^n 佩诺亚余项：(一般是研究局部问题的时候使用，研究一个邻域上的问题) f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... +o((x-x_0)^n) 主要作用： 计算高阶导数 ：使用佩诺亚余项 y=f(x) ，计算其中的， y = f(x) = f(x_0) + \\frac{1}{1!}f'(x_0)(x-x_0) + \\frac{1}{2!}f''(x_0)(x-x_0)^2 + .... 而f(x)本身如果知道泰勒公式，即可用对应指数项相同直接计算高阶导数值 证明高阶导数： 使用拉格朗日余项 一般展开时候，x 选择知道函数值的位置，x_0 选择知道导数的位置 .. 导数的应用 "},"English/":{"url":"English/","title":"英语","keywords":"","body":"英语笔记 技巧 "},"English/Dictionary.html":{"url":"English/Dictionary.html","title":"词汇集","keywords":"","body":"词汇表 英文 翻译 pay attion to 对...引起注意 rudely 粗鲁的 turn aroud 环顾四周 none of your business 与你无关 theater / theatre 戏院 cinema 电影院 movie film 电影 cling film 保鲜膜 fair play 公平竞争 play a role in ... 起到..作用 slavery 奴隶制 founding generation 奠基的一代人 focus 关注 "},"English/Remember.html":{"url":"English/Remember.html","title":"背诵集合","keywords":"","body":"词汇表 英文 翻译 pay attion to 对...引起注意 rudely 粗鲁的 focus 关注 "},"English/Grammar.html":{"url":"English/Grammar.html","title":"语法","keywords":"","body":"语法 "},"CS/":{"url":"CS/","title":"专业","keywords":"","body":""},"CS/Computer-composition-principle.html":{"url":"CS/Computer-composition-principle.html","title":"计算机组成原理","keywords":"","body":""},"CS/data-structure.html":{"url":"CS/data-structure.html","title":"数据结构","keywords":"","body":"考点 通用ADT(抽象数据类型)的一些操作函数的名称，下面的Adt都是类型名，例如Queue队列 InitAdt(&A) // 构造新的数据类型，赋值给对象A DestroyAdt(&A) // 销毁A (对象空间完成删除) ClearAdt(&A) // 清空A (对象内容删除) AdtEmpty(A) // 判空. 空--TRUE AdtLength(A) // 取对象的所有长度 GetHead (A,&e) // 取对象的头元素, EnAdt (&A,e) // 入对象，例如EnQueue：如队 DeAdt (&A,&e) // 出对象 AdtTraverse(A,visit()) //遍历 为了区分循环队列的队空和队满，会选择牺牲一个空间，不存数据，顺序循环队列式，rear(队尾)不存数据，链式循环队列式front(队头)不存数据 KMP算法，进行主子串匹配对比逻辑相对复杂，核心逻辑为 先遍历子串得出每个字符位i，使得 i-j+1到 i-1位的串 和1到j-1的串完全相同的相应j的值，即为next[i]数组 再遍历主串，当匹配失败的时候，根据子串的失败的位置，子串回溯到指定位置，主串不动 当子串回溯后发现还不队，会继续回溯，当回溯到0的时候，主串和子串都会往前近一位 . 绪论 思考方法： ​ 问题驱动 \\to 三步走(绘制逻辑结构、定义存储结构、编写算法) 基本概念和术语 数据(data)—所有能输入到计算机中去的描述客观事物的符号 数值性数据 非数值性数据(多媒体信息处理) 数据元素(data element)—数据的基本单位，也称结点(node)或记录(record) 数据项(data item)—有独立含义的数据最小单位，也称域(field) 数据对象(Data Object):相同特性数据元素的集合，是数据的一个子集 数据结构(Data Structure) = 逻辑结构 + 存储结构 + 操作 定义：是相互之间存在一种或多种特定关系的数据元素的集合。 ​ 是带“结构”的数据元素的集合,“结构”就是指数据元素之间存在的关系。 ​ 是2+1 (两个层次和一个操作) 逻辑结构： 数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题 抽象出来的数学模型。（唯一） 分为4种：集合(无关系)，线性(1:1)，树(1.m)，图(m:n) 也可以划分为： 线性结构(线性表、栈、队列、串) 和 非线性结构(树、图) 存储结构(物理结构)：数据 元素 及其 关系 在计算机存储器中的存储方式。（不唯一） 分为4种：顺序(连续)，链式(不连续)，索引(字典)，散列(离散存储，效率最高) 操作(运算、行为)：执行不同功能的算法 数据类型 定义:在一种程序设计语言中,变量所具有的数据种类 抽象数据类型 (ADTs: AbstractData Types) 就是平常使用的类，ADT = ( D ,S P) 数据对象 + 数据关系 + 基本操作 更高层次的数据抽象 由用户定义,用以表示应用问题的数据模型 由基本的数据类型组成, 并包括一组相关的操作 算法和算法分析 算法定义 一个有穷的指令集,这些指令为解决某一特定任务规定了一个运算序列 算法的特性 输入、 输出、 确定性、 有穷性、 可行性 算法设计的评价 正确性、 可读性、 健壮性(鲁棒性)、 高效性(时间代价和空间代价) 算法效率的度量 算法效率的指标：时间和空间来度量 时间复杂度 空间复杂度 算法效率的度量：时间复杂度 算法效率的计算： 事后统计：利用计算机内的计时功能,不同算法的程序可以用一组或多组相同的统计数据区分 缺点: 必须先运行依据算法编制的程序 所得时间统计量依赖于硬件、软件等环境因素,掩盖算法本身的劣 事前分析估计: 一个高级语言程序在计算机上运行所消耗的时间取决于: 依据的算法选用何种策略 问题的规模 程序语言 编译程序产生机器代码质量 机器执行指令速度 时间复杂度的渐进表示法: 一般情况下,算法中基本操作重复执行的时间是问题规模 n 的某个函数 f(n),算法执行的时间的增长率和 f(n)的增长率相同,称渐近时间复杂度。 时间复杂度的表示方法有两种：大 O 法、语句频度法 T(n) = kO(C(n)) C是语句执行频次的最高次数的指数 已知时间复杂度：O(1) 算法效率的度量:空间复杂度 定义 三个组成部分 存储算法本身所占用的空间 算法的输入/输出数据占用的空间 算法在运行过程中临时占用的辅助空间 原地工作:若辅助空间相对于输入数据量是常数,则称此算法是原地工作。 说明: 若所占空间量依赖于特定的输入,按最坏情况来分析 线性表 线性结构 定义 若结构是非空有限集,则有且仅有一个开始结点和一个终端结点,并且所有结点都最多只有一个直接前趋和一个直接后继。 线性结构表达式:(a 1 ,a 2 ,......,a n ) 线性结构的特点 只有一个首结点和尾结点; 除首尾结点外,其他结点只有一个直接前驱和一个直接后继。 线性结构反映结点间的逻辑关系是一对一 线性结构包括线性表、堆栈、队列、字符串、数组等等。其中,最典型、最常用的是：线性表 线性表 类型定义 线性表的顺序存储 线性表的链式存储 重要基本操作 初始化 取值 查找 插入 删除 顺序表(顺序存储结构) 定义和实现 线性表的顺序表示又称为顺序存储结构、顺序映像、顺序表。 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简言之,逻辑上相邻,物理上也相邻 顺序存储方法：用一组地址连续的存储单元依次存储线性表的元素,可通过数组 V[n]来实现。 实现： typedef struct { ElemType *elem; //指向数据元素的基地址 int length; //线性表的当前长度 }SqList; 重要操作 初始化 //构造一个空的顺序表 L Status InitList_Sq(SqList &L) { L.elem=new ElemType[MAXSIZE]; //为顺序表分配空间 if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length=0; //空表长度为 0 return OK; } //构造一个空的顺序表 指针L Status InitList_Sq(SqList *L) { L->elem=new ElemType[MAXSIZE];//为顺序表分配空间 if(! L->elem) exit(OVERFLOW); //存储分配失败 L->length=0;//空表长度为 0 return OK; } // 销毁线性表 L void DestroyList(SqList &L) { if (L.elem) delete[]L.elem; //释放存储空间 } // 清空线性表 L void ClearList(SqList &L) { L.length=0; //将线性表的长度置为 0 } // 求线性表 L 的长度 int GetLength(SqList L) { return (L.length); } // 判断线性表 L 是否为空 int IsEmpty(SqList L) { if (L.length==0) return 1; else return 0; } 取值 Status GetElem(SqList L,int i,ElemType &e) { if (iL.length) return ERROR; //判断 i 值是否合理,若不合理,返回 ERROR e=L.elem[i-1]; //第 i-1 的单元存储着第 i 个数据 return OK; } 查找 int LocateELem(SqList L,ElemType e) { for (i=0;i 插入 位置插入需要迁移的次数：n-i+1次 Status ListInsert_Sq(SqList &L,int i ,ElemType e){ if(iL.length+1) return ERROR; //i 值不合法 if(L.length==MAXSIZE) return ERROR;//当前存储空间已满 for(j=L.length-1;j>=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素 e 放入第 i 个位置 ++L.length; //表长增 1 return OK; } 步骤： 判断位置i是否合法 判断顺序表存储是否够 将第 n 至第 i 位的元素依次向后移动一个位置,空出第 i 个位置。 将要插入的新元素 e 放入第 i 个位置。 表长加 1,插入成功返回 OK。 T = O(n) ，移动次数为 n/2 删除 Status ListDelete_Sq(SqList &L,int i){ if((iL.length)) return ERROR; //i 值不合法 for (j=i;j 特点 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系,即线性表的逻辑结构与存储结构一致 在访问线性表时,可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为,访问每个元素所花时间相等，这种存取元素的方法被称为随机存取法 顺序表的优缺点： 优点: 存储密度大(结点本身所占存储量/结点结构所占存储量) 可以随机存取表中任一元素 缺点: 在插入、删除某一元素时，需要移动大量元素，浪费存储空间 属于静态存储形式,数据元素的个数不能自由扩充 链式表(链式存储结构) 定义和实现 链式存储结构： 结点在存储器中的位置是任意的,即逻辑上相邻的数据元素在物理上不一定相邻 线性表的链式表示又称为非顺序映像或链式映像。 术语 结点:数据元素的存储映像。由数据域和指针域两部分组成 链表: n 个结点由指针链组成一个链表。它是线性表的链式存储映像,称为线性表的链式存储结构 单链表、双链表、循环链表: 结点只有一个指针域的链表,称为单链表或线性链表 有两个指针域的链表,称为双链表 首尾相接的链表称为循环链表 头指针、头结点和首元结点 头指针是指向链表中第一个结点的指针 首元结点是指链表中存储第一个数据元素 a 1 的结点 头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信 息(头节点不一定存在) 如何表示空表 有头结点时，当头结点的指针域为空时 表示空表 即 head->next = null 在链表中设置头结点的好处 便于首元结点的处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致,无须进行特殊处理; 便于空表和非空表的统一处理 无论链表是否为空,头指针都是指向头结点的非空指针,因此空表和非空表的处理也就统一了。 头结点的数据域内装的是 头结点的数据域可以为空,也可存放线性表长度等附加信息,但此结点不能计入链表长度值。 实现： typedef struct LNode{ ElemType data; //数据域 struct LNode *next; //指针域 }LNode,*LinkList; // *LinkList 为 Lnode 类型的指针 LNode *p; // 上下等价 LinkList p; LNode *p 指针变量 p:表示结点地址 结点变量*p:表示一个结点 重要操作 初始化 Status InitList_L(LinkList &L) { L=new LNode; // 头节点 L->next=NULL; return OK; } // 销毁，删除所有节点，包括头节点 Status DestroyList_L(LinkList &L) { LinkList p; while(L) { p=L; L=L->next; delete p; } return OK } // 清空，把L变成空表，即头节点不变，删除其他所有节点 Status ClearList(LinkList & L) { LinkList p,q; p=L->next; //p 指向第一个结点 while(p) { q=p->next; delete p; p=q; } L->next=NULL; //头结点指针域为空 return OK; } // 求表长，返回 L 中数据元素个数 int ListLength_L(LinkList L) { LinkList p; p=L->next; i=0; while(p) { i++; p=p->next; } return i; } // 判断表是否为空，若 L 为空表,则返回 1,否则返回 0 int ListEmpty(LinkList L) { if(L->next) //非空 return 0; else return 1; } 算法步骤: 生成新结点作头结点 用头指针 L 指向头结点 头结点的指针域置空 取值 Status GetElem_L(LinkList L,int i,ElemType &e) { p=L->next; j=1; //初始化 while(p && jnext; ++j; } if(!p || j>i) return ERROR; //第 i 个元素不存在 e=p->data; //取第 i 个元素 return OK; }//GetElem_L 查找 //在线性表 L 中查找值为 e 的数据元素地址，返回 L 中值为 e 的数据元素的地址,查找失败返回 NULL LNode *LocateELem_L (LinkList L,Elemtype e) { p=L->next; while(p &&p->data!=e) p=p->next; return p; } //在线性表 L 中查找值为 e 的数据元素序号，返回 L 中值为 e 的数据元素的位置序号,查找失败返回 0 int LocateELem_L (LinkList L,Elemtype e) { p=L->next; j=1; while(p &&p->data!=e) { p=p->next; j++; } if(p) return j; else return 0; } 插入 //在 L 中第 i 个元素之前插入数据元素 e Status ListInsert_L(LinkList &L,int i,ElemType e){ p=L;j=0; while(p&&jnext; ++j; } //寻找第 i−1 个结点 if(!p||j>i−1) return ERROR; //i 大于表长+ 1 或者小于 1 s=new LNode; //生成新结点 s s->data=e; //将结点 s 的数据域置为 e s->next=p->next; //将结点 s 插入 L 中 p->next=s; return OK; }//ListInsert_L 删除 //将线性表 L 中第 i 个数据元素删除 Status ListDelete_L(LinkList &L,int i,ElemType &e){ p=L;j=0; while(p->next &&jnext; ++j; } if(!(p->next)||j>i-1) return ERROR; //删除位置不合理 q=p->next;//临时保存被删结点的地址以备释放 p->next=q->next;//改变删除结点前驱结点的指针域 // 等价于 p->next=p->next->next; e=q->data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; } //ListDelete_L 单表的建立(数据导入) // 前插法，类似堆栈，先进存在后面 void CreateList_F(LinkList &L,int n) { L=new LNode; L->next=NULL; //先建立一个带头结点的单链表 for(i=n;i>0;--i) { p=new LNode; //生成新结点 cin>>p->data; //输入元素值 p->next=L->next; L->next=p; //插入到表头 } }//CreateList_F // 尾插法，正位序输入 n 个元素的值,建立带表头结点的单链表 L void CreateList_L(LinkList &L,int n){ L=new LNode; L->next=NULL; r=L; //尾指针 r 指向头结点 for(i=0;i>p->data; //输入元素值 p->next=NULL; r->next=p; //插入到表尾 r=p; //r 指向新的尾结点 } }//CreateList_L 循环链表 和单链不同，循环链表的遍历循环条件： p!=L p->next!=L // 两个循环链表的合并 LinkList Connect(LinkList Ta,LinkList Tb) // 假设 Ta、Tb 都是非空的单循环链表 { p=Ta->next; //p 存表头结点 Ta->next=Tb->next->next; //Tb 表头连结 Ta 表尾 deleteTb->next; //释放 Tb 表头结点 Tb->next=p; //修改指针 returnTb; } 双向链表 // 定义 typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode, *DuLinkList; // 插入 Status ListAdd_DuL(LinkList &L,int i,ElemType e){ p=L;j=0; while(p&&jnext; ++j; } //寻找第 i−1 个结点 if(!p||j>i−1) return ERROR; //i 大于表长+ 1 或者小于 1 s=new LNode; //生成新结点 s s->data=e; //将结点 s 的数据域置为 e s->prior=p->prior; // 节点s前驱是p的前驱 p->prior->next=s; // 节点p前驱的后继改为s s->next=p; p->prior=s; //将结点 s 插入 L 中 p->next=s; return OK; } // 删除 Status ListDelete_DuL(DuLinkList &L,int i,ElemType &e){ if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p->data; p->prior->next=p->next; p->next->prior=p->prior; delete p; return OK; } 特点 链表的优缺点 优点 数据元素的个数可以自由扩充 插入、删除等操作不必移动数据,只需修改链接指针,修改效率较高 缺点 存储密度小 存取效率不高,必须采用顺序存取,即存取数据元素时,只能按链表的顺序进行访问(顺藤摸瓜) 链表的运算时间效率分析 查找:因线性链表只能顺序存取,即在查找时要从头指针找起,查找的时间复杂度为 O(n)。 插入和删除:因线性链表不需要移动元素,只要修改指针,一般情况下时间复杂度为 O(1)。 但是,如果要在单链表中进行前插或删除操作,由于要从头查找前驱结点,所耗时间复杂度为 O(n) 。 应用 顺序表合并 void union(SqList &La, SqList Lb){ La_len=ListLength(La); // 获取顺序表长度 Lb_len=ListLength(Lb); for(i=1;i 有序表合并 SqList union(SqList &La, SqList Lb){ La_len=ListLength(La); Lb_len=ListLength(Lb); Lc=new SqList[La_len+Lb_len]; i=1; j=1; for(i=1;i S(n)= O(n) 且 T(n)= O(ListLength(LA) + ListLength(LB)) 有序链表合并 void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){ pa=La->next; pb=Lb->next; pc=Lc=La; //用 La 的头结点作为 Lc 的头结点 while(pa && pb){ if(pa->datadata) { pc->next=pa; pc=pa; pa=pa->next; } else { pc->next=pb; pc=pb; pb=pb->next; } pc->next=pa?pa:pb; //插入剩余段 delete Lb; //释放 Lb 的头结点 } 重点 掌握线性表的逻辑结构特性是数据元素之间存在着线性关系,在计算机中表 这种关系的两类不同的存储结构是顺序存储结构(顺序表)和链式存储结构(链表)。 熟练掌握这两类存储结构的描述方法,掌握链表中的头结点、头指针和首元结点的区别及循环链表、双向链表的特点等。 熟练掌握顺序表的查找、插入和删除算法 熟练掌握链表的查找、插入和删除算法 能够从时间和空间复杂度的角度比较两种存储结构的不同特点及其适用场合 栈和队列 栈 栈的定义和特点 定义： 只能在表的一端(栈顶 top)进行插入和删除运算的线性表 逻辑结构： 与线性表相同,仍为一对一关系 存储结构： 用顺序栈或链栈存储均可,但以顺序栈更常见 运算规则 只能在栈顶运算,且访问结点时依照后进先出(LIFO)或先进后出 (FILO)的原则 主要操作 入栈和出栈函数,具体实现依顺序栈或链栈的不同而不同 基本操作有：入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等 . 栈的表示和操作实现 顺序栈 表示 #define MAXSIZE 100 typedef struct { SElemType *base; SElemType *top; int stacksize; }SqStack; 基本操作 // 初始化 Status InitStack( SqStack &S ) { S.base =new SElemType[MAXSIZE]; if( !S.base ) return OVERFLOW; S.top = S.base; S.stackSize = MAXSIZE; return OK; } // 判断是否为空 bool StackEmpty( SqStack S ) { if(S.top == S.base) return true; else return false; } // 求长度 int StackLength( SqStack S ) { return S.top – S.base; } // 清空栈 Status ClearStack( SqStack &S ) { if( S.base ) S.top = S.base; return OK; } // 销毁栈 Status DestroyStack( SqStack &S ){ if( S.base ) { delete S.base ; S.stacksize = 0; S.base = S.top = NULL; } return OK; } 进栈 Status Push( SqStack &S, SElemType e) { if( S.top - S.base== S.stacksize ) // 栈满 return ERROR; *S.top++=e; // 等价于 *S.top=e; *S.top++; return OK; } 出栈 Status Pop( SqStack &S, SElemType &e) { if( S.top == S.base ) // 栈空 return ERROR; e= *--S.top; // 等价于 *S.top--; e=*S.top; return OK; } 取顺序栈栈顶元素 Status GetTop( SqStack S, SElemType &e) { if( S.top == S.base ) return ERROR; e = *( S.top – 1 ); return OK; } . 链式栈 表示 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode,*LinkStack; LinkStack S; 基本操作 // 初始化 void InitStack(LinkStack &S ) { S=NULL; } // 判断是否为空 Status StackEmpty(LinkStack S) { if (S==NULL) return TRUE; else return FALSE; } 进栈 Status Push(LinkStack &S ,SElemType e) { p=new StackNode; if (!p) exit(OVERFLOW); p->data=e; p->next=S; S=p; return OK; } 出栈 Status Pop (LinkStack &S,SElemType &e) { if (S==NULL) return ERROR; e = S-> data; p = S; S = S-> next; delete p; return OK; } 取链栈栈顶元素 SElemType GetTop(LinkStack S) { if (S==NULL) exit(1); else return S–>data; } 递归 递归的定义 若一个对象部分地包含它自己,或用 它自己给自己定义,则称这个对象是递归的; 若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。 求解递归问题方法 分治法:对于一个较为复杂的问题,能够分解成几个相对简单的且解法相同或类似的子问题来求解 必备的三个条件: 能将一个问题转变成一个新问题,而新问题与原问题的解法相同或类同,不同的仅是处理的对象,且这些处理对象是变化有规律的 可以通过上述转化而使问题简化 必须有一个明确的递归出口,或称递归的边界 基本形式 void p(参数表) { if (递归结束条件) 可直接求解步骤; else p(较小的参数); } 队列 队列的定义和特点 定义：只能在表的一端(队尾)进行插入,在另一端(队头)进行删除运算的线性表 逻辑结构：与线性表相同,仍为一对一关系 存储结构：用顺序队列或链队存储均可 运算规则：先进先出(FIFO) 主要操作：入队和出队函数,具体实现依顺序队或链队的不同而不同 队列的表示和操作 顺序队列 -- 循环队列 循环队列的表示 #define M 100 //最大队列长度 typedef struct { QElemType*base; //初始化的动态分配存储空间 int front; //头指针 int rear; //尾指针 }SqQueue; // 入队 base[rear++]=x; // 出队 x=base[front++]; 在创建队列后，出现，入队在到达指定Max值时就判断队列已满，但如果这时候也有出队情况，就有出队的空间得不到利用的问题 解决办法就是循环队列，正常考试中，默认顺序队列就是循环队列 循环队列的基本操作 // 初始化 Status InitQueue (SqQueue &Q){ Q.base =new QElemType[MAXQSIZE]; if(!Q.base) exit(OVERFLOW); Q.front=Q.rear=0; return OK; } // 长度(可能rear饶了一圈在front后面) int QueueLength (SqQueue Q){ return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; } // 空队列 Q.rear==Q.front; // 队列满 (Q.rear+1)%MAXQSIZE==Q.front // 最大长度(牺牲一个空间，区分队满和队空) M-1 循环队列的入队 Status EnQueue(SqQueue&Q,QElemTypee){ if((Q.rear+1)%MAXQSIZE==Q.front) // 队满 return ERROR; Q.base[Q.rear]=e; Q.rear=(Q.rear+1)%MAXQSIZE; return OK; } 循环队列的出队 Status DeQueue (LinkQueue &Q,QElemType &e){ if(Q.front==Q.rear) // 队空 return ERROR; e=Q.base[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; return OK; } 链循环队列 表示 typedef struct QNode{ QElemType data; struct Qnode *next; }Qnode, *QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 }LinkQueue; 基本操作 // 初始化 Status InitQueue (LinkQueue &Q){ Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front->next=NULL; return OK; } // 销毁队列 Status DestroyQueue (LinkQueue &Q){ while(Q.front){ Q.rear=Q.front->next; free(Q.front); Q.front=Q.rear; } return OK; } // 判断是否为空 Status QueueEmpty (LinkQueue Q){ return (Q.front==Q.rear); } // 获取队头元素 Status GetHead (LinkQueue Q, QElemType&e){ if(Q.front==Q.rear) return ERROR; e=Q.front->next->data; return OK; } 入队 Status EnQueue(LinkQueue &Q,QElemTypee){ p=(QueuePtr)malloc(sizeof(QNode)); // 申请创造一个空间 if(!p) exit(OVERFLOW); p->data=e; p->next=NULL; Q.rear->next=p; Q.rear=p; return OK; } 出队 Status DeQueue (LinkQueue &Q,QElemType &e){ if(Q.front==Q.rear) return ERROR; p=Q.front->next; e=p->data; Q.front->next=p->next; if(Q.rear==p) Q.rear=Q.front; delete p; return OK; } 串、数组和广义表 串 串的术语 串名:S; 串值: 用单引号括起来的字符序列。 长度: 串中字符的数目。 空串: 含零个字符的串 ∅表示 空格串: 由一个或多个空格组成的串。 子串: 串中任意个连续的字符组成的子序列。 字符在串的位置: 字符在序列中的序号。 子串在串的位置: 子串的第一个字符在串中的位置。 相等:当且仅当两个串的值相等。 串的比较 通过组成串的字符之间的比较来进行的，从第一位往后比，若有值大，那字符串就大 给定两个串:X=“x_1 x_2... x_n ”和 Y=“y_1 y_2 ...y_m ”,则: 当 n=m 且 x_1 =y_1 ,...,x_n =y_m 时,称 X=Y; 当下列条件之一成立时,称 X n 且 x_i =y_i (1≤i≤n); 存在 k≤min(m,n) ,使得 x_i =y_i (1≤i≤k-1)且 x k 。 串与线性表区别 串的数据对象约束为字符集。 串的基本操作与线性表有很大差别 线性表的基本操作中,大多以“单个元素”作为操作对象,如查找某个元素、在某个位置上插入一个元素和删除一个元素。 串的基本操作中,通常以“串的整体”作为操作对象。 如在串中查找某个子串、在串的某个位置上插入一个子串以及删除一个子串。 串的表示 定长顺序存储表示 用一组地址连续的存储单元存储串值的字符序列。 非压缩形式:一个数组单元存储一个字符——浪费空间。 压缩形式:一个数组单元存储多个字符——算法复杂。 如何表示串的长度： 用一个变量来表示串的实际长度。 在串尾存储一个不会在串中出现的特殊字符作为串的终结符,表示串的结尾。 用数组的 0 号单元存放串的长度,从 1 号单元开始存放串值。 堆分配存储表示 系统开辟一个串值存储空间(串值可利用空间),同时建立一个符号表; 建立一个新串时,在可利用空间分配,并在符号表中记录下串变量名、串值在可利用空间的位置、串长度等信息。 串的链式存储表示 也称作串的块链式存储表示 串的模式匹配 模式匹配:给定主串 S=“s_1 s_2 ...s_n ”和模式 T=“t_1 t_2 ...t_m ”,在 S 中寻找 T 的过程称为模式匹配。如果匹配成功,返回 T 在 S 中的位置,如果匹配失败,返回 0。 模式匹配问题的特点: 算法的一次执行时间不容忽视:问题规模通常很大,常常需要在大量信息中进行匹配; 算法改进所取得的积累效益不容忽视:模式匹配操作经常被调用,执行频率高。 模式匹配——BF 算法 遍历主串和子串，拿子串第一个开始遍历比较主串，如果是相同的，则一起比较下一个，如果有一个比较式不一致的，子串回到第一个开始比较，主串第一成功位置的下一个 基本思想: 从主串 S 的第一个字符开始和模式 T 的第一个字符进行比较,若相等,则继续比较两者的后续字符;否则,从主串 S 的第二个字符开始和模式 T 的第一个字符进行比较,重复上述过程,直到 T 中的字符全部比较完毕,则说明本趟匹配成功;或 S 中字符全部比较完,则说明匹配失败。 算法过程 在串 S 和串 T 中设比较的起始下标 i 和 j; 循环直到 S 或 T 的所有字符均比较完; 如果 S[i]=T[j],继续比较 S 和 T 的下一个字符; 否则,将 i 和 j 回溯，i变成i-j+2，j变成1,准备下一趟比较; 如果 T 中所有字符均比较完,则匹配成功,返回匹配的起始比较下标; 否则,匹配失败,返回 0; BF 算法步骤 入口函数(主串、模式串、起始位置) 两个变量,一个是在主串下标变量 i,一个是子串下标变量 j 在两个串中比较，如果相同,下标下移;否则退回 匹配成功返回在主串中的位置;否则返回 0 表示失败 算法性能 设串 S 长度为 n,串 T 长度为 m,在匹配成功的情况下,考虑两种极端情况: 最好情况,即不成功匹配都发生在串 T 的第 1 个字符。 设匹配成功发生在 s_i 处,则在 i-1 趟不成功的匹配中共比较了 i-1 次,第 i 趟成功的配共比较了 m 次,所以总共比较了 i-1+m 次,所有匹配成功的可能情况共有 n-m+1 种,则O(n+m) 最坏情况,不成功匹配都发生在串 T 的最后一个字符。 算法描述 // T[0] 存放串长度 int Index_BF (SString S,SString T, int pos) { i= pos,j =1; while (iT[0]) return i-T[0]; /*匹配成功*/ else return 0; /*返回不匹配标志*/ } . 模式匹配——KMP算法(Knuth Morris Pratt) 分析过程 因 p_1 ≠p_2 ,s_2 =p_2 ,必有 s_2 ≠p_1 ,又因 p_1 =p_3 ,s_3 =p_3 ,所以必有 s_3 =p_1 ; 因此,第二次匹配可直接从 i=4, j=2 开始。 改进思想 每趟匹配过程中出现字符比较不等时,不回溯主指针 i,利用已得到的“部分匹配”结果将模式向右滑动尽可能远的一段距离,继续进行比较。 next[j]函数的意义 next[j]函数表征着模式 P 中最大相同首子串和尾子串(真子串)的长度。可见,模式中相似部分越多,则 next[j]函数越大,它既表示模式串中的字符之间的相关度越高,模式串向右滑动得越远,与主串进行比较的次数越少,时间复杂度就越低。 回溯模式串,也就是子串 主串中的 i 可以不回溯,模式向右滑动到的新比较起点 k ,并且 k 仅与模式 串 P(模式串)T 有关! 关注两个问题: 如何由当前部分匹配结果确定模式向右滑动的新比较起点 k? 模式应该向右滑多远才是最高效率的? 计算 next[j]的方法 当 j=1 时 next[j]=0; next[j]=0 表示根本不进行字符比较 当 j>1 时 next[j]的值为:模式串的位置从 1 到 j-1 构成的串中所出现的首尾相同的子串的最大长度加 1。 当无首尾相同的子串时 next[j]的值为 1 next[j]=1 表示从模式串头部开始进行字符比较 算法逻辑 对匹配的子串，进行遍历分析，找出，每个串的位置j，在之前j-1中是否有重复，即出现1～k-1与j-k+1～j-1的串值是完全一致的，由此以j为下标组成数组next[j]，这就是回溯时，主串不动，子串迁移的位置。 这个遍历计算的逻辑是：当i位的字符向前一位匹配不对，就向前一直匹配，如果都不相同则为0 当匹配的子串的小串为0时，整个遍历都往前一位，并且让标出这位回溯到1,也就是从头开始，因为他没有一个相同的 next[i]=j，就是表明子串第i-j+1到第i-1位在和顺位前j-1位是相同的 在遍历主串，这次遍历中，如果要回溯，只是子串回溯，主串不动。 整个算法先执行get_next得出子串的回溯数组，再执行Index_KMP匹配计算 特殊情况的优化： 若按上述定义得到 next[j]=k,而模式中 p_j =p_k ,则为主串中字符 s_i和 p_j 比较不等时,不需要再和 p_k 进行比较,而直接和 p_{next[k]} 进行比较 换句话说,此时的next[j]应和 next[k]相同。 算法 int Index_KMP (SString S,SString T, int pos) { i= pos; j =1; while (iT[0]) return i-T[0]; /*匹配成功*/ else return 0; /*返回不匹配标志*/ } void get_next(SString T, int &next[]) { i= 1; next[1] = 0; j = 0; while( i 时间复杂度 设主串 s 的长度为 n,模式串 t 长度为 m,在 KMP 算法中求 next 数组的时间复杂度为O(m),在后面的匹配中因主串 s 的下标不减即不回溯,比较次数可记为 n,所以 KMP算法总的时间复杂度为 O(n+m)。 数组 概念 数组是由一组个数固定,类型相同的数据元素组成阵列。 以二维数组为例:二维数组中的每个元素都受两个线性关系的约束。 即行关系和列关系,在每个关系中,每个元素 aij 都有且仅有一个直接前趋,都有且仅有一个直接后继。 顺序存储结构 一维数组在内存中的存放很简单,只要顺序存放在连续的内存单元即可。 二维数组 因为内存地址是一维的,而数组是二维的,要将二维数组挤入一维的地址中,有两个策略：以行为主序、以列为主序 元素存储地址的计算 假设二维数组 A 每个元素占用 s 个存储单元, Loc(a00 ) 是 a00 存储位置, 也是二维数组 A 的基址 Loc(aij )为元素 aij 的存储地址 以行为主，即先行后列：Loc(a_{ij} ) = Loc(a_{00} ) +(n* i+j )*s 以列为主，即先列后行：Loc(a_{ij} ) = Loc(a_{00} ) +(n* j+i )*s . 矩阵 矩阵压缩 特殊矩阵的压缩存储 (对称矩阵、 上(下)三角矩阵、带状矩阵) 稀疏矩阵的压缩存储 . 广义表 定义 广义表也称为列表,是线性表的一种扩展,也是数据元素的有限序列 说明: 广义表的定义是一个递归定义,因为在描述广义 表时又用到了广义表; 在线性表中数据元素是单个元素,而在广义表中, 元素可以是单个元素, 称为单元素(原子),也可以是广 义表,称为广义表的子表; n 是广义表长度; E=(a,E) 即为递归广义表 广义表的运算: 若广义表不空,则可分成表头和表尾,反之,一对表头和表尾可唯一确定广义表。 对非空广义表: 称第一个元素为 L 的表头,其余元素组成的表称为 LS 的表尾 例如： A=((a)) GetHead(A)=(a) GetTail(A)=() 若A=(a,b,(c,d),(e,(f,g)))，则 GetHead(GetTail(GetHead(GetTail(GetTail(A)))))=d 广义表的存储结构 由于广义表中数据元素可以具有不同结构,故 难以用顺序结构表示广义表。通常采用链表存储方式 广义表中的数据元素可能为单元素(原子)或子表,由此需要两种结点: 表结点,用以表示广义表; 单元素结点,用以表示单元素 树与二叉树 概念 树的定义 树是由 n(n≥0)个结点组成的有限集合。若 n=0,称 为空树;若 n>0,则: 有一个特定的称为根(root)的结点。它只有直接后继,但没 有直接前驱; 除根结点以外的其它结点可以划分为 m(m≥0)个互不相交的有限集合T_0,T_1...T_{m-1} ,每个集合 T i (i=0,1,...,m-1)又是一棵树,称为根的子树,每棵子树的根结点有且仅有一个直接前驱,但可以有 0 个或多个直接后继。 树的描述 树的逻辑结构可以用二元组描述为: tree =(K,R) K={k i ∣1≤i≤n;n≥0,k i ∈elemtype} R={r} 树的基本术语 结点 指树中的一个数据元素,一般用一个字母表示。 度 一个结点包含子树的数目,称为该结点的度。 树叶(叶子) 度为 0 的结点,称为叶子结点或树叶,也叫终端结点。 孩子结点 若结点 X 有子树,则子树的根结点为 X 的孩子结点,也称为孩子。 "},"CS/operating-system.html":{"url":"CS/operating-system.html","title":"操作系统","keywords":"","body":"概念 操作系统(OS)也叫做 系统软件 OS作为计算机系统资源的管理者 OS用作扩展机、虚拟机 OS作为用户和计算机硬件系统的接口 接口形式： 系统调用 -- 用于编程 命令输入 (命令行、GUI、NUI(语音识别)) -- 用于交互控制 ... 考点 和硬件相关(组成原理)的东西都不是操作系统管的 .. 操作系统的特征、功能和提供的服务 基本特征(四大特征) 并发(Concurrence) -- 基本特征 并行是多个事件在同一时刻发生，并发是多个事件在同一时间段内发生；当时间段无限趋近0的时候并发即为并行。 计算机是顺序执行的，所以计算机处理问题是并发的； 共享(Sharing) 虚拟(Virtual) 异步性(Asynchronism) 多个进程“走走停停“，一起执行 由于上述特征导致程序失去 封闭性 功能(管理和分配资源) 进程管理(进程与线程) 存储管理(内存管理) 文件管理(文件系统) 输入输出管理(设备管理) 作业管理(大型计算机) 操作系统提供的服务(接口) 公共服务(用命令控制计算机) 系统调用服务(各个功能模块) 操作系统的发展与分类 操作系统的发展 从无到有 从简单到复杂 从单机到联网 从专用到通用再到专用 操作系统的分类 无操作系统的人工操作方式 脱机输入/输出(Off-Line I/O)方式——monitor 单用户操作系统 (OS) 单/多道批处理系统(大型计算中心) 分时系统(通用交互式系统) 实时系统(工控/军事) 网络操作系统(增加了资源共享和通信功能) 分布式操作系统(用户透明/强壮) 并行操作系统 (高效) 操作系统的运行环境 内核态与用户态 用户态只能用自己的资源，内核态只能访问系统资源，他们是用户态调用内核态的关系，而这个调用时候使用的就是访管指令 内核态与用户态是指进程(线程)在执行代码过程中为了安全保护而设置的二个不同的阶段。 内核态可以执行所有的系统代码，包括特权指令 而用户态只能执行用户的代码。 若用户需要执行特权代码时，必须发起一次系统调用。 中断、异常 中断(interrupt)是指处理机对系统中或系统外发生的异步事件的响应。 异常(陷阱 trap)是指由系统发起的一次确定的服务过程(也称为软中断)、也算用户态转为内核态的访管指令 访管指令(用户态转为内核态的指令) 不是 特权指令(处理器对内核的特殊操作) 用户从用户态进入内核态必定通过访管指令 从内核态返回用户态可以修改状态字实现 系统调用 系统调用是指当用户需要使用某些计算机资源时，因为这些资源是被操作系统所控制的，用户不能直接使用该资源，而是必须向操作系统提出“请求”，由操作系统安排合理、高效、安全地使用这些资源 这种“请求”便称为系统调用 这种“请求”的格式通常是指令名加上请求的服务识别号(有时是中断号) 操作系统体系结构 单一结构(小型嵌入式) 分层结构(用户层/内核下层/内核上层) 客户/服务器结构(微内核) 虚拟机结构(容器) 进程管理 进程与线程 进程概念 一个具有一定独立功能的程序对某个数据集合上的一次动态执行过程和资源分配过程 进程包含的重要元素: 代码(指令) Code 数据 Data 进程表(进程控制块) PT(PCB) 唯一标志 进程和程序的区别与联系 进程是动态的，程序是静态的 进程是暂时的，程序是永久的 进程和程序的组成不同： 程序主要包含代码和数据 进程除了包含代码和数据以外，还有进程表 进程和程序间有非常紧密的联系 程序经过多次创建，可以对应不同的进程 一个进程通过系统调用，可以被多个程序所使用 进程的状态与转换 三种基本状态 就绪(Ready)状态 执行(Running)状态 阻塞(Blocking)状态 四种转换 执行——>阻塞(出事) 执行——>就绪(时间到) 就绪——>执行(调度) 阻塞——>就绪(事毕) 五状态模型（三基础模型上） 创建(create) 终止(terminal) 七状态模型（五状态模型上） 就绪挂起(Ready Suspend) 阻塞挂起(Blocked Suspend) 挂起即为把资源从内存放到外面 进程控制 进程的创建(创建原语) 进程的创建过程 申请空白进程表 为新进程分配资源 初始化进程表 将新进程插入就绪队列 进程的终止 正常结束(自愿的) 异常结束 出现错误控制退出(自愿的) 致命错误被迫退出(非自愿的) 外界干预(非自愿的) 进程的终止过程 从进程控制块中读出该进程的状态 若被终止进程正处于执行状态，立即终止该进程的执行 若该进程还有子孙进程，还应将其所有子孙进程予以终止 将被终止进程所拥有的全部资源，或者归还给其父进程， 或者归还给系统 将被终止进程的进程控制块移出 进程的阻塞与唤醒的出发原因 请求系统服务 启动某种操作 新数据尚未到达 无新工作可做 进程的挂起与激活 进程组织 进程表中的信息 进程管理信息: 进程号，处理器寄存器，优先级等 存储资源分配: 代码指针，数据指针，堆和栈的指针等 文件资源信息: 句柄，描述符，设备等 链接方式 就绪队列链表(一般为一个) 阻塞队列链表(可能依据不同阻塞原因有多个队列链表) 索引方式 就绪队列索引 阻塞队列索引 ... 进程通信 Shared memory(共享内存) 共享某些数据结构(有名) 共享内存区域(指针) Message(消息机制) 发送原语 send(receiver，message) 接收原语 receive(sender，message) 异步实现 Pipe(管道) 原语自动实现同步 实现阻塞读，非阻塞读或阻塞写或非阻塞写 实现方法 read/write，不支持 lseek Signal(信号) Socket(套接字) 线程概念与多线程模型 线程概念：提高并发性 进程是实体。 资源分配目标是进程、调度分派优先是线程 线程的属性 轻型实体(容易创建和撤销) 独立调度和分派的基本单位 可并发执行 共享进程资源 适应硬件的发展 在具有线程 OS 中，进程是作为拥有系统资源的基本单位， 进程不再作为一个执行的实体。 具有线程的 OS 中的进程有以下属性: 作为系统资源分配的单位 可包括多个线程 进程变为了不是一个可执行的实体 线程间的同步和通信 互斥锁(mutex):互斥锁是一种比较简单的、用于实现线程间对资源互斥访 问的机制 条件变量 线程共享同一进程的全局变量 内核支持线程 内核支持线程是在内核的支持下运行的，即无论是用户进程中的线程， 还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实 现的。 在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根 据该控制块而感知某线程的存在的，并对其加以控制 处理机调度 调度的基本概念 作业调度——进入内存(宏观调度/高级调度) 进程/线程调度——占用处理器(微观调度/低级调度) 交换调度——位于何处(中级调度) 高级调度(High Scheduling)，宏观调度，作业调度 在每次执行作业调度时(由外存创建到内存成为进程)，都须做出以下两个决定: 接纳多少个作业 接纳哪些作业 中级调度(Intermediate-Level Scheduling) ，中程调度 引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量 中级调度的算法主要由内存管理来实现，与高级调度和低级调度的算法不同 故一般在存储管理中分析，虚拟存储的中级调度即页面调入、置换等实现 低级调度(Low Level Scheduling)，微观调度，进程调度，线程调度 调度的方式: 非抢占方式(Non-preemptive Mode) 抢占方式(Preemptive Mode)... 调度时机、切换与过程 时机、切换 调度器(scheduler)/切换器(dispatcher 也称分派器)(均是系统代码级程序) 策略与机制 调度队列 上下文(context)切换 过程(例如:分时系统) 时钟中断，响应，时间片到(时机) 激活调度器，调度器占用 CPU 运行(很少代码很短时间)，按照调度算法选出下一个运行的进程 激活切换器，切换器占用 CPU 运行(很少代码很短时间)，将原处理器上进程撤下，将新进程装入 将 CPU 交由新进程运行 调度的基本准则 公平 策略执行 平衡 调度方法 典型调度算法 "},"CS/computer-network.html":{"url":"CS/computer-network.html","title":"计算机网络","keywords":"","body":""}}